{"ast":null,"code":"import PDFNumber from \"../objects/PDFNumber\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFRef from \"../objects/PDFRef\";\nimport PDFAcroTerminal from \"./PDFAcroTerminal\";\nimport PDFAcroNonTerminal from \"./PDFAcroNonTerminal\";\nimport PDFAcroSignature from \"./PDFAcroSignature\";\nimport PDFAcroText from \"./PDFAcroText\";\nimport PDFAcroPushButton from \"./PDFAcroPushButton\";\nimport PDFAcroRadioButton from \"./PDFAcroRadioButton\";\nimport PDFAcroCheckBox from \"./PDFAcroCheckBox\";\nimport PDFAcroComboBox from \"./PDFAcroComboBox\";\nimport PDFAcroListBox from \"./PDFAcroListBox\";\nimport { AcroButtonFlags, AcroChoiceFlags } from \"./flags\";\nexport var createPDFAcroFields = function (kidDicts) {\n  if (!kidDicts) return [];\n  var kids = [];\n  for (var idx = 0, len = kidDicts.size(); idx < len; idx++) {\n    var ref = kidDicts.get(idx);\n    var dict = kidDicts.lookup(idx);\n    // if (dict instanceof PDFDict) kids.push(PDFAcroField.fromDict(dict));\n    if (ref instanceof PDFRef && dict instanceof PDFDict) {\n      kids.push([createPDFAcroField(dict, ref), ref]);\n    }\n  }\n  return kids;\n};\nexport var createPDFAcroField = function (dict, ref) {\n  var isNonTerminal = isNonTerminalAcroField(dict);\n  if (isNonTerminal) return PDFAcroNonTerminal.fromDict(dict, ref);\n  return createPDFAcroTerminal(dict, ref);\n};\n// TODO: Maybe just check if the dict is *not* a widget? That might be better.\n// According to the PDF spec:\n//\n//   > A field's children in the hierarchy may also include widget annotations\n//   > that define its appearance on the page. A field that has children that\n//   > are fields is called a non-terminal field. A field that does not have\n//   > children that are fields is called a terminal field.\n//\n// The spec is not entirely clear about how to determine whether a given\n// dictionary represents an acrofield or a widget annotation. So we will assume\n// that a dictionary is an acrofield if it is a member of the `/Kids` array\n// and it contains a `/T` entry (widgets do not have `/T` entries). This isn't\n// a bullet proof solution, because the `/T` entry is technically defined as\n// optional for acrofields by the PDF spec. But in practice all acrofields seem\n// to have a `/T` entry defined.\nvar isNonTerminalAcroField = function (dict) {\n  var kids = dict.lookup(PDFName.of('Kids'));\n  if (kids instanceof PDFArray) {\n    for (var idx = 0, len = kids.size(); idx < len; idx++) {\n      var kid = kids.lookup(idx);\n      var kidIsField = kid instanceof PDFDict && kid.has(PDFName.of('T'));\n      if (kidIsField) return true;\n    }\n  }\n  return false;\n};\nvar createPDFAcroTerminal = function (dict, ref) {\n  var ftNameOrRef = getInheritableAttribute(dict, PDFName.of('FT'));\n  var type = dict.context.lookup(ftNameOrRef, PDFName);\n  if (type === PDFName.of('Btn')) return createPDFAcroButton(dict, ref);\n  if (type === PDFName.of('Ch')) return createPDFAcroChoice(dict, ref);\n  if (type === PDFName.of('Tx')) return PDFAcroText.fromDict(dict, ref);\n  if (type === PDFName.of('Sig')) return PDFAcroSignature.fromDict(dict, ref);\n  // We should never reach this line. But there are a lot of weird PDFs out\n  // there. So, just to be safe, we'll try to handle things gracefully instead\n  // of throwing an error.\n  return PDFAcroTerminal.fromDict(dict, ref);\n};\nvar createPDFAcroButton = function (dict, ref) {\n  var _a;\n  var ffNumberOrRef = getInheritableAttribute(dict, PDFName.of('Ff'));\n  var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber);\n  var flags = (_a = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a !== void 0 ? _a : 0;\n  if (flagIsSet(flags, AcroButtonFlags.PushButton)) {\n    return PDFAcroPushButton.fromDict(dict, ref);\n  } else if (flagIsSet(flags, AcroButtonFlags.Radio)) {\n    return PDFAcroRadioButton.fromDict(dict, ref);\n  } else {\n    return PDFAcroCheckBox.fromDict(dict, ref);\n  }\n};\nvar createPDFAcroChoice = function (dict, ref) {\n  var _a;\n  var ffNumberOrRef = getInheritableAttribute(dict, PDFName.of('Ff'));\n  var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber);\n  var flags = (_a = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a !== void 0 ? _a : 0;\n  if (flagIsSet(flags, AcroChoiceFlags.Combo)) {\n    return PDFAcroComboBox.fromDict(dict, ref);\n  } else {\n    return PDFAcroListBox.fromDict(dict, ref);\n  }\n};\nvar flagIsSet = function (flags, flag) {\n  return (flags & flag) !== 0;\n};\nvar getInheritableAttribute = function (startNode, name) {\n  var attribute;\n  ascend(startNode, function (node) {\n    if (!attribute) attribute = node.get(name);\n  });\n  return attribute;\n};\nvar ascend = function (startNode, visitor) {\n  visitor(startNode);\n  var Parent = startNode.lookupMaybe(PDFName.of('Parent'), PDFDict);\n  if (Parent) ascend(Parent, visitor);\n};","map":{"version":3,"names":["PDFNumber","PDFDict","PDFName","PDFArray","PDFRef","PDFAcroTerminal","PDFAcroNonTerminal","PDFAcroSignature","PDFAcroText","PDFAcroPushButton","PDFAcroRadioButton","PDFAcroCheckBox","PDFAcroComboBox","PDFAcroListBox","AcroButtonFlags","AcroChoiceFlags","createPDFAcroFields","kidDicts","kids","idx","len","size","ref","get","dict","lookup","push","createPDFAcroField","isNonTerminal","isNonTerminalAcroField","fromDict","createPDFAcroTerminal","of","kid","kidIsField","has","ftNameOrRef","getInheritableAttribute","type","context","createPDFAcroButton","createPDFAcroChoice","_a","ffNumberOrRef","ffNumber","lookupMaybe","flags","asNumber","flagIsSet","PushButton","Radio","Combo","flag","startNode","name","attribute","ascend","node","visitor","Parent"],"sources":["E:/PROA/frontPROA/node_modules/pdf-lib/es/core/acroform/utils.js"],"sourcesContent":["import PDFNumber from \"../objects/PDFNumber\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFRef from \"../objects/PDFRef\";\nimport PDFAcroTerminal from \"./PDFAcroTerminal\";\nimport PDFAcroNonTerminal from \"./PDFAcroNonTerminal\";\nimport PDFAcroSignature from \"./PDFAcroSignature\";\nimport PDFAcroText from \"./PDFAcroText\";\nimport PDFAcroPushButton from \"./PDFAcroPushButton\";\nimport PDFAcroRadioButton from \"./PDFAcroRadioButton\";\nimport PDFAcroCheckBox from \"./PDFAcroCheckBox\";\nimport PDFAcroComboBox from \"./PDFAcroComboBox\";\nimport PDFAcroListBox from \"./PDFAcroListBox\";\nimport { AcroButtonFlags, AcroChoiceFlags } from \"./flags\";\nexport var createPDFAcroFields = function (kidDicts) {\n    if (!kidDicts)\n        return [];\n    var kids = [];\n    for (var idx = 0, len = kidDicts.size(); idx < len; idx++) {\n        var ref = kidDicts.get(idx);\n        var dict = kidDicts.lookup(idx);\n        // if (dict instanceof PDFDict) kids.push(PDFAcroField.fromDict(dict));\n        if (ref instanceof PDFRef && dict instanceof PDFDict) {\n            kids.push([createPDFAcroField(dict, ref), ref]);\n        }\n    }\n    return kids;\n};\nexport var createPDFAcroField = function (dict, ref) {\n    var isNonTerminal = isNonTerminalAcroField(dict);\n    if (isNonTerminal)\n        return PDFAcroNonTerminal.fromDict(dict, ref);\n    return createPDFAcroTerminal(dict, ref);\n};\n// TODO: Maybe just check if the dict is *not* a widget? That might be better.\n// According to the PDF spec:\n//\n//   > A field's children in the hierarchy may also include widget annotations\n//   > that define its appearance on the page. A field that has children that\n//   > are fields is called a non-terminal field. A field that does not have\n//   > children that are fields is called a terminal field.\n//\n// The spec is not entirely clear about how to determine whether a given\n// dictionary represents an acrofield or a widget annotation. So we will assume\n// that a dictionary is an acrofield if it is a member of the `/Kids` array\n// and it contains a `/T` entry (widgets do not have `/T` entries). This isn't\n// a bullet proof solution, because the `/T` entry is technically defined as\n// optional for acrofields by the PDF spec. But in practice all acrofields seem\n// to have a `/T` entry defined.\nvar isNonTerminalAcroField = function (dict) {\n    var kids = dict.lookup(PDFName.of('Kids'));\n    if (kids instanceof PDFArray) {\n        for (var idx = 0, len = kids.size(); idx < len; idx++) {\n            var kid = kids.lookup(idx);\n            var kidIsField = kid instanceof PDFDict && kid.has(PDFName.of('T'));\n            if (kidIsField)\n                return true;\n        }\n    }\n    return false;\n};\nvar createPDFAcroTerminal = function (dict, ref) {\n    var ftNameOrRef = getInheritableAttribute(dict, PDFName.of('FT'));\n    var type = dict.context.lookup(ftNameOrRef, PDFName);\n    if (type === PDFName.of('Btn'))\n        return createPDFAcroButton(dict, ref);\n    if (type === PDFName.of('Ch'))\n        return createPDFAcroChoice(dict, ref);\n    if (type === PDFName.of('Tx'))\n        return PDFAcroText.fromDict(dict, ref);\n    if (type === PDFName.of('Sig'))\n        return PDFAcroSignature.fromDict(dict, ref);\n    // We should never reach this line. But there are a lot of weird PDFs out\n    // there. So, just to be safe, we'll try to handle things gracefully instead\n    // of throwing an error.\n    return PDFAcroTerminal.fromDict(dict, ref);\n};\nvar createPDFAcroButton = function (dict, ref) {\n    var _a;\n    var ffNumberOrRef = getInheritableAttribute(dict, PDFName.of('Ff'));\n    var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber);\n    var flags = (_a = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a !== void 0 ? _a : 0;\n    if (flagIsSet(flags, AcroButtonFlags.PushButton)) {\n        return PDFAcroPushButton.fromDict(dict, ref);\n    }\n    else if (flagIsSet(flags, AcroButtonFlags.Radio)) {\n        return PDFAcroRadioButton.fromDict(dict, ref);\n    }\n    else {\n        return PDFAcroCheckBox.fromDict(dict, ref);\n    }\n};\nvar createPDFAcroChoice = function (dict, ref) {\n    var _a;\n    var ffNumberOrRef = getInheritableAttribute(dict, PDFName.of('Ff'));\n    var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber);\n    var flags = (_a = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a !== void 0 ? _a : 0;\n    if (flagIsSet(flags, AcroChoiceFlags.Combo)) {\n        return PDFAcroComboBox.fromDict(dict, ref);\n    }\n    else {\n        return PDFAcroListBox.fromDict(dict, ref);\n    }\n};\nvar flagIsSet = function (flags, flag) {\n    return (flags & flag) !== 0;\n};\nvar getInheritableAttribute = function (startNode, name) {\n    var attribute;\n    ascend(startNode, function (node) {\n        if (!attribute)\n            attribute = node.get(name);\n    });\n    return attribute;\n};\nvar ascend = function (startNode, visitor) {\n    visitor(startNode);\n    var Parent = startNode.lookupMaybe(PDFName.of('Parent'), PDFDict);\n    if (Parent)\n        ascend(Parent, visitor);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}