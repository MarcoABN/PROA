{"ast":null,"code":"import { __extends } from \"tslib\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFPageLeaf from \"./PDFPageLeaf\";\nimport { InvalidTargetIndexError, CorruptPageTreeError } from \"../errors\";\nvar PDFPageTree = /** @class */function (_super) {\n  __extends(PDFPageTree, _super);\n  function PDFPageTree() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  PDFPageTree.prototype.Parent = function () {\n    return this.lookup(PDFName.of('Parent'));\n  };\n  PDFPageTree.prototype.Kids = function () {\n    return this.lookup(PDFName.of('Kids'), PDFArray);\n  };\n  PDFPageTree.prototype.Count = function () {\n    return this.lookup(PDFName.of('Count'), PDFNumber);\n  };\n  PDFPageTree.prototype.pushTreeNode = function (treeRef) {\n    var Kids = this.Kids();\n    Kids.push(treeRef);\n  };\n  PDFPageTree.prototype.pushLeafNode = function (leafRef) {\n    var Kids = this.Kids();\n    this.insertLeafKid(Kids.size(), leafRef);\n  };\n  /**\n   * Inserts the given ref as a leaf node of this page tree at the specified\n   * index (zero-based). Also increments the `Count` of each page tree in the\n   * hierarchy to accomodate the new page.\n   *\n   * Returns the ref of the PDFPageTree node into which `leafRef` was inserted,\n   * or `undefined` if it was inserted into the root node (the PDFPageTree upon\n   * which the method was first called).\n   */\n  PDFPageTree.prototype.insertLeafNode = function (leafRef, targetIndex) {\n    var Kids = this.Kids();\n    var Count = this.Count().asNumber();\n    if (targetIndex > Count) {\n      throw new InvalidTargetIndexError(targetIndex, Count);\n    }\n    var leafsRemainingUntilTarget = targetIndex;\n    for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n      if (leafsRemainingUntilTarget === 0) {\n        // Insert page and return\n        this.insertLeafKid(idx, leafRef);\n        return undefined;\n      }\n      var kidRef = Kids.get(idx);\n      var kid = this.context.lookup(kidRef);\n      if (kid instanceof PDFPageTree) {\n        if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\n          // Dig in\n          return kid.insertLeafNode(leafRef, leafsRemainingUntilTarget) || kidRef;\n        } else {\n          // Move on\n          leafsRemainingUntilTarget -= kid.Count().asNumber();\n        }\n      }\n      if (kid instanceof PDFPageLeaf) {\n        // Move on\n        leafsRemainingUntilTarget -= 1;\n      }\n    }\n    if (leafsRemainingUntilTarget === 0) {\n      // Insert page at the end and return\n      this.insertLeafKid(Kids.size(), leafRef);\n      return undefined;\n    }\n    // Should never get here if `targetIndex` is valid\n    throw new CorruptPageTreeError(targetIndex, 'insertLeafNode');\n  };\n  /**\n   * Removes the leaf node at the specified index (zero-based) from this page\n   * tree. Also decrements the `Count` of each page tree in the hierarchy to\n   * account for the removed page.\n   *\n   * If `prune` is true, then intermediate tree nodes will be removed from the\n   * tree if they contain 0 children after the leaf node is removed.\n   */\n  PDFPageTree.prototype.removeLeafNode = function (targetIndex, prune) {\n    if (prune === void 0) {\n      prune = true;\n    }\n    var Kids = this.Kids();\n    var Count = this.Count().asNumber();\n    if (targetIndex >= Count) {\n      throw new InvalidTargetIndexError(targetIndex, Count);\n    }\n    var leafsRemainingUntilTarget = targetIndex;\n    for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n      var kidRef = Kids.get(idx);\n      var kid = this.context.lookup(kidRef);\n      if (kid instanceof PDFPageTree) {\n        if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\n          // Dig in\n          kid.removeLeafNode(leafsRemainingUntilTarget, prune);\n          if (prune && kid.Kids().size() === 0) Kids.remove(idx);\n          return;\n        } else {\n          // Move on\n          leafsRemainingUntilTarget -= kid.Count().asNumber();\n        }\n      }\n      if (kid instanceof PDFPageLeaf) {\n        if (leafsRemainingUntilTarget === 0) {\n          // Remove page and return\n          this.removeKid(idx);\n          return;\n        } else {\n          // Move on\n          leafsRemainingUntilTarget -= 1;\n        }\n      }\n    }\n    // Should never get here if `targetIndex` is valid\n    throw new CorruptPageTreeError(targetIndex, 'removeLeafNode');\n  };\n  PDFPageTree.prototype.ascend = function (visitor) {\n    visitor(this);\n    var Parent = this.Parent();\n    if (Parent) Parent.ascend(visitor);\n  };\n  /** Performs a Post-Order traversal of this page tree */\n  PDFPageTree.prototype.traverse = function (visitor) {\n    var Kids = this.Kids();\n    for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n      var kidRef = Kids.get(idx);\n      var kid = this.context.lookup(kidRef);\n      if (kid instanceof PDFPageTree) kid.traverse(visitor);\n      visitor(kid, kidRef);\n    }\n  };\n  PDFPageTree.prototype.insertLeafKid = function (kidIdx, leafRef) {\n    var Kids = this.Kids();\n    this.ascend(function (node) {\n      var newCount = node.Count().asNumber() + 1;\n      node.set(PDFName.of('Count'), PDFNumber.of(newCount));\n    });\n    Kids.insert(kidIdx, leafRef);\n  };\n  PDFPageTree.prototype.removeKid = function (kidIdx) {\n    var Kids = this.Kids();\n    var kid = Kids.lookup(kidIdx);\n    if (kid instanceof PDFPageLeaf) {\n      this.ascend(function (node) {\n        var newCount = node.Count().asNumber() - 1;\n        node.set(PDFName.of('Count'), PDFNumber.of(newCount));\n      });\n    }\n    Kids.remove(kidIdx);\n  };\n  PDFPageTree.withContext = function (context, parent) {\n    var dict = new Map();\n    dict.set(PDFName.of('Type'), PDFName.of('Pages'));\n    dict.set(PDFName.of('Kids'), context.obj([]));\n    dict.set(PDFName.of('Count'), context.obj(0));\n    if (parent) dict.set(PDFName.of('Parent'), parent);\n    return new PDFPageTree(dict, context);\n  };\n  PDFPageTree.fromMapWithContext = function (map, context) {\n    return new PDFPageTree(map, context);\n  };\n  return PDFPageTree;\n}(PDFDict);\nexport default PDFPageTree;\n//# sourceMappingURL=PDFPageTree.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}