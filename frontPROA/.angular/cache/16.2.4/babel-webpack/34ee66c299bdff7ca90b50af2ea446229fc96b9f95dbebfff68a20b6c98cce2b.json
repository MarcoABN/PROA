{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport PDFCrossRefSection from \"../document/PDFCrossRefSection\";\nimport PDFHeader from \"../document/PDFHeader\";\nimport PDFTrailer from \"../document/PDFTrailer\";\nimport { MissingKeywordError, MissingPDFHeaderError, PDFInvalidObjectParsingError, ReparseError, StalledParserError } from \"../errors\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFInvalidObject from \"../objects/PDFInvalidObject\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFRawStream from \"../objects/PDFRawStream\";\nimport PDFRef from \"../objects/PDFRef\";\nimport ByteStream from \"./ByteStream\";\nimport PDFObjectParser from \"./PDFObjectParser\";\nimport PDFObjectStreamParser from \"./PDFObjectStreamParser\";\nimport PDFXRefStreamParser from \"./PDFXRefStreamParser\";\nimport PDFContext from \"../PDFContext\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { Keywords } from \"../syntax/Keywords\";\nimport { IsDigit } from \"../syntax/Numeric\";\nimport { waitForTick } from \"../../utils\";\nvar PDFParser = /** @class */function (_super) {\n  __extends(PDFParser, _super);\n  function PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {\n    if (objectsPerTick === void 0) {\n      objectsPerTick = Infinity;\n    }\n    if (throwOnInvalidObject === void 0) {\n      throwOnInvalidObject = false;\n    }\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n    var _this = _super.call(this, ByteStream.of(pdfBytes), PDFContext.create(), capNumbers) || this;\n    _this.alreadyParsed = false;\n    _this.parsedObjects = 0;\n    _this.shouldWaitForTick = function () {\n      _this.parsedObjects += 1;\n      return _this.parsedObjects % _this.objectsPerTick === 0;\n    };\n    _this.objectsPerTick = objectsPerTick;\n    _this.throwOnInvalidObject = throwOnInvalidObject;\n    return _this;\n  }\n  PDFParser.prototype.parseDocument = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var prevOffset, offset;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.alreadyParsed) {\n              throw new ReparseError('PDFParser', 'parseDocument');\n            }\n            this.alreadyParsed = true;\n            this.context.header = this.parseHeader();\n            _a.label = 1;\n          case 1:\n            if (!!this.bytes.done()) return [3 /*break*/, 3];\n            return [4 /*yield*/, this.parseDocumentSection()];\n          case 2:\n            _a.sent();\n            offset = this.bytes.offset();\n            if (offset === prevOffset) {\n              throw new StalledParserError(this.bytes.position());\n            }\n            prevOffset = offset;\n            return [3 /*break*/, 1];\n          case 3:\n            this.maybeRecoverRoot();\n            if (this.context.lookup(PDFRef.of(0))) {\n              console.warn('Removing parsed object: 0 0 R');\n              this.context.delete(PDFRef.of(0));\n            }\n            return [2 /*return*/, this.context];\n        }\n      });\n    });\n  };\n  PDFParser.prototype.maybeRecoverRoot = function () {\n    var isValidCatalog = function (obj) {\n      return obj instanceof PDFDict && obj.lookup(PDFName.of('Type')) === PDFName.of('Catalog');\n    };\n    var catalog = this.context.lookup(this.context.trailerInfo.Root);\n    if (!isValidCatalog(catalog)) {\n      var indirectObjects = this.context.enumerateIndirectObjects();\n      for (var idx = 0, len = indirectObjects.length; idx < len; idx++) {\n        var _a = indirectObjects[idx],\n          ref = _a[0],\n          object = _a[1];\n        if (isValidCatalog(object)) {\n          this.context.trailerInfo.Root = ref;\n        }\n      }\n    }\n  };\n  PDFParser.prototype.parseHeader = function () {\n    while (!this.bytes.done()) {\n      if (this.matchKeyword(Keywords.header)) {\n        var major = this.parseRawInt();\n        this.bytes.assertNext(CharCodes.Period);\n        var minor = this.parseRawInt();\n        var header = PDFHeader.forVersion(major, minor);\n        this.skipBinaryHeaderComment();\n        return header;\n      }\n      this.bytes.next();\n    }\n    throw new MissingPDFHeaderError(this.bytes.position());\n  };\n  PDFParser.prototype.parseIndirectObjectHeader = function () {\n    this.skipWhitespaceAndComments();\n    var objectNumber = this.parseRawInt();\n    this.skipWhitespaceAndComments();\n    var generationNumber = this.parseRawInt();\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.obj)) {\n      throw new MissingKeywordError(this.bytes.position(), Keywords.obj);\n    }\n    return PDFRef.of(objectNumber, generationNumber);\n  };\n  PDFParser.prototype.matchIndirectObjectHeader = function () {\n    var initialOffset = this.bytes.offset();\n    try {\n      this.parseIndirectObjectHeader();\n      return true;\n    } catch (e) {\n      this.bytes.moveTo(initialOffset);\n      return false;\n    }\n  };\n  PDFParser.prototype.parseIndirectObject = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var ref, object;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            ref = this.parseIndirectObjectHeader();\n            this.skipWhitespaceAndComments();\n            object = this.parseObject();\n            this.skipWhitespaceAndComments();\n            // if (!this.matchKeyword(Keywords.endobj)) {\n            // throw new MissingKeywordError(this.bytes.position(), Keywords.endobj);\n            // }\n            // TODO: Log a warning if this fails...\n            this.matchKeyword(Keywords.endobj);\n            if (!(object instanceof PDFRawStream && object.dict.lookup(PDFName.of('Type')) === PDFName.of('ObjStm'))) return [3 /*break*/, 2];\n            return [4 /*yield*/, PDFObjectStreamParser.forStream(object, this.shouldWaitForTick).parseIntoContext()];\n          case 1:\n            _a.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            if (object instanceof PDFRawStream && object.dict.lookup(PDFName.of('Type')) === PDFName.of('XRef')) {\n              PDFXRefStreamParser.forStream(object).parseIntoContext();\n            } else {\n              this.context.assign(ref, object);\n            }\n            _a.label = 3;\n          case 3:\n            return [2 /*return*/, ref];\n        }\n      });\n    });\n  };\n  // TODO: Improve and clean this up\n  PDFParser.prototype.tryToParseInvalidIndirectObject = function () {\n    var startPos = this.bytes.position();\n    var msg = \"Trying to parse invalid object: \" + JSON.stringify(startPos) + \")\";\n    if (this.throwOnInvalidObject) throw new Error(msg);\n    console.warn(msg);\n    var ref = this.parseIndirectObjectHeader();\n    console.warn(\"Invalid object ref: \" + ref);\n    this.skipWhitespaceAndComments();\n    var start = this.bytes.offset();\n    var failed = true;\n    while (!this.bytes.done()) {\n      if (this.matchKeyword(Keywords.endobj)) {\n        failed = false;\n      }\n      if (!failed) break;\n      this.bytes.next();\n    }\n    if (failed) throw new PDFInvalidObjectParsingError(startPos);\n    var end = this.bytes.offset() - Keywords.endobj.length;\n    var object = PDFInvalidObject.of(this.bytes.slice(start, end));\n    this.context.assign(ref, object);\n    return ref;\n  };\n  PDFParser.prototype.parseIndirectObjects = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var initialOffset, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.skipWhitespaceAndComments();\n            _a.label = 1;\n          case 1:\n            if (!(!this.bytes.done() && IsDigit[this.bytes.peek()])) return [3 /*break*/, 8];\n            initialOffset = this.bytes.offset();\n            _a.label = 2;\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n            return [4 /*yield*/, this.parseIndirectObject()];\n          case 3:\n            _a.sent();\n            return [3 /*break*/, 5];\n          case 4:\n            e_1 = _a.sent();\n            // TODO: Add tracing/logging mechanism to track when this happens!\n            this.bytes.moveTo(initialOffset);\n            this.tryToParseInvalidIndirectObject();\n            return [3 /*break*/, 5];\n          case 5:\n            this.skipWhitespaceAndComments();\n            // TODO: Can this be done only when needed, to avoid harming performance?\n            this.skipJibberish();\n            if (!this.shouldWaitForTick()) return [3 /*break*/, 7];\n            return [4 /*yield*/, waitForTick()];\n          case 6:\n            _a.sent();\n            _a.label = 7;\n          case 7:\n            return [3 /*break*/, 1];\n          case 8:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  PDFParser.prototype.maybeParseCrossRefSection = function () {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.xref)) return;\n    this.skipWhitespaceAndComments();\n    var objectNumber = -1;\n    var xref = PDFCrossRefSection.createEmpty();\n    while (!this.bytes.done() && IsDigit[this.bytes.peek()]) {\n      var firstInt = this.parseRawInt();\n      this.skipWhitespaceAndComments();\n      var secondInt = this.parseRawInt();\n      this.skipWhitespaceAndComments();\n      var byte = this.bytes.peek();\n      if (byte === CharCodes.n || byte === CharCodes.f) {\n        var ref = PDFRef.of(objectNumber, secondInt);\n        if (this.bytes.next() === CharCodes.n) {\n          xref.addEntry(ref, firstInt);\n        } else {\n          // this.context.delete(ref);\n          xref.addDeletedEntry(ref, firstInt);\n        }\n        objectNumber += 1;\n      } else {\n        objectNumber = firstInt;\n      }\n      this.skipWhitespaceAndComments();\n    }\n    return xref;\n  };\n  PDFParser.prototype.maybeParseTrailerDict = function () {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.trailer)) return;\n    this.skipWhitespaceAndComments();\n    var dict = this.parseDict();\n    var context = this.context;\n    context.trailerInfo = {\n      Root: dict.get(PDFName.of('Root')) || context.trailerInfo.Root,\n      Encrypt: dict.get(PDFName.of('Encrypt')) || context.trailerInfo.Encrypt,\n      Info: dict.get(PDFName.of('Info')) || context.trailerInfo.Info,\n      ID: dict.get(PDFName.of('ID')) || context.trailerInfo.ID\n    };\n  };\n  PDFParser.prototype.maybeParseTrailer = function () {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.startxref)) return;\n    this.skipWhitespaceAndComments();\n    var offset = this.parseRawInt();\n    this.skipWhitespace();\n    this.matchKeyword(Keywords.eof);\n    this.skipWhitespaceAndComments();\n    this.matchKeyword(Keywords.eof);\n    this.skipWhitespaceAndComments();\n    return PDFTrailer.forLastCrossRefSectionOffset(offset);\n  };\n  PDFParser.prototype.parseDocumentSection = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.parseIndirectObjects()];\n          case 1:\n            _a.sent();\n            this.maybeParseCrossRefSection();\n            this.maybeParseTrailerDict();\n            this.maybeParseTrailer();\n            // TODO: Can this be done only when needed, to avoid harming performance?\n            this.skipJibberish();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * This operation is not necessary for valid PDF files. But some invalid PDFs\n   * contain jibberish in between indirect objects. This method is designed to\n   * skip past that jibberish, should it exist, until it reaches the next\n   * indirect object header, an xref table section, or the file trailer.\n   */\n  PDFParser.prototype.skipJibberish = function () {\n    this.skipWhitespaceAndComments();\n    while (!this.bytes.done()) {\n      var initialOffset = this.bytes.offset();\n      var byte = this.bytes.peek();\n      var isAlphaNumeric = byte >= CharCodes.Space && byte <= CharCodes.Tilde;\n      if (isAlphaNumeric) {\n        if (this.matchKeyword(Keywords.xref) || this.matchKeyword(Keywords.trailer) || this.matchKeyword(Keywords.startxref) || this.matchIndirectObjectHeader()) {\n          this.bytes.moveTo(initialOffset);\n          break;\n        }\n      }\n      this.bytes.next();\n    }\n  };\n  /**\n   * Skips the binary comment following a PDF header. The specification\n   * defines this binary comment (section 7.5.2 File Header) as a sequence of 4\n   * or more bytes that are 128 or greater, and which are preceded by a \"%\".\n   *\n   * This would imply that to strip out this binary comment, we could check for\n   * a sequence of bytes starting with \"%\", and remove all subsequent bytes that\n   * are 128 or greater. This works for many documents that properly comply with\n   * the spec. But in the wild, there are PDFs that omit the leading \"%\", and\n   * include bytes that are less than 128 (e.g. 0 or 1). So in order to parse\n   * these headers correctly, we just throw out all bytes leading up to the\n   * first indirect object header.\n   */\n  PDFParser.prototype.skipBinaryHeaderComment = function () {\n    this.skipWhitespaceAndComments();\n    try {\n      var initialOffset = this.bytes.offset();\n      this.parseIndirectObjectHeader();\n      this.bytes.moveTo(initialOffset);\n    } catch (e) {\n      this.bytes.next();\n      this.skipWhitespaceAndComments();\n    }\n  };\n  PDFParser.forBytesWithOptions = function (pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {\n    return new PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers);\n  };\n  return PDFParser;\n}(PDFObjectParser);\nexport default PDFParser;","map":{"version":3,"names":["__awaiter","__extends","__generator","PDFCrossRefSection","PDFHeader","PDFTrailer","MissingKeywordError","MissingPDFHeaderError","PDFInvalidObjectParsingError","ReparseError","StalledParserError","PDFDict","PDFInvalidObject","PDFName","PDFRawStream","PDFRef","ByteStream","PDFObjectParser","PDFObjectStreamParser","PDFXRefStreamParser","PDFContext","CharCodes","Keywords","IsDigit","waitForTick","PDFParser","_super","pdfBytes","objectsPerTick","throwOnInvalidObject","capNumbers","Infinity","_this","call","of","create","alreadyParsed","parsedObjects","shouldWaitForTick","prototype","parseDocument","prevOffset","offset","_a","label","context","header","parseHeader","bytes","done","parseDocumentSection","sent","position","maybeRecoverRoot","lookup","console","warn","delete","isValidCatalog","obj","catalog","trailerInfo","Root","indirectObjects","enumerateIndirectObjects","idx","len","length","ref","object","matchKeyword","major","parseRawInt","assertNext","Period","minor","forVersion","skipBinaryHeaderComment","next","parseIndirectObjectHeader","skipWhitespaceAndComments","objectNumber","generationNumber","matchIndirectObjectHeader","initialOffset","e","moveTo","parseIndirectObject","parseObject","endobj","dict","forStream","parseIntoContext","assign","tryToParseInvalidIndirectObject","startPos","msg","JSON","stringify","Error","start","failed","end","slice","parseIndirectObjects","e_1","peek","trys","push","skipJibberish","maybeParseCrossRefSection","xref","createEmpty","firstInt","secondInt","byte","n","f","addEntry","addDeletedEntry","maybeParseTrailerDict","trailer","parseDict","get","Encrypt","Info","ID","maybeParseTrailer","startxref","skipWhitespace","eof","forLastCrossRefSectionOffset","isAlphaNumeric","Space","Tilde","forBytesWithOptions"],"sources":["E:/PROA/frontPROA/node_modules/pdf-lib/es/core/parser/PDFParser.js"],"sourcesContent":["import { __awaiter, __extends, __generator } from \"tslib\";\nimport PDFCrossRefSection from \"../document/PDFCrossRefSection\";\nimport PDFHeader from \"../document/PDFHeader\";\nimport PDFTrailer from \"../document/PDFTrailer\";\nimport { MissingKeywordError, MissingPDFHeaderError, PDFInvalidObjectParsingError, ReparseError, StalledParserError, } from \"../errors\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFInvalidObject from \"../objects/PDFInvalidObject\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFRawStream from \"../objects/PDFRawStream\";\nimport PDFRef from \"../objects/PDFRef\";\nimport ByteStream from \"./ByteStream\";\nimport PDFObjectParser from \"./PDFObjectParser\";\nimport PDFObjectStreamParser from \"./PDFObjectStreamParser\";\nimport PDFXRefStreamParser from \"./PDFXRefStreamParser\";\nimport PDFContext from \"../PDFContext\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { Keywords } from \"../syntax/Keywords\";\nimport { IsDigit } from \"../syntax/Numeric\";\nimport { waitForTick } from \"../../utils\";\nvar PDFParser = /** @class */ (function (_super) {\n    __extends(PDFParser, _super);\n    function PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {\n        if (objectsPerTick === void 0) { objectsPerTick = Infinity; }\n        if (throwOnInvalidObject === void 0) { throwOnInvalidObject = false; }\n        if (capNumbers === void 0) { capNumbers = false; }\n        var _this = _super.call(this, ByteStream.of(pdfBytes), PDFContext.create(), capNumbers) || this;\n        _this.alreadyParsed = false;\n        _this.parsedObjects = 0;\n        _this.shouldWaitForTick = function () {\n            _this.parsedObjects += 1;\n            return _this.parsedObjects % _this.objectsPerTick === 0;\n        };\n        _this.objectsPerTick = objectsPerTick;\n        _this.throwOnInvalidObject = throwOnInvalidObject;\n        return _this;\n    }\n    PDFParser.prototype.parseDocument = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var prevOffset, offset;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (this.alreadyParsed) {\n                            throw new ReparseError('PDFParser', 'parseDocument');\n                        }\n                        this.alreadyParsed = true;\n                        this.context.header = this.parseHeader();\n                        _a.label = 1;\n                    case 1:\n                        if (!!this.bytes.done()) return [3 /*break*/, 3];\n                        return [4 /*yield*/, this.parseDocumentSection()];\n                    case 2:\n                        _a.sent();\n                        offset = this.bytes.offset();\n                        if (offset === prevOffset) {\n                            throw new StalledParserError(this.bytes.position());\n                        }\n                        prevOffset = offset;\n                        return [3 /*break*/, 1];\n                    case 3:\n                        this.maybeRecoverRoot();\n                        if (this.context.lookup(PDFRef.of(0))) {\n                            console.warn('Removing parsed object: 0 0 R');\n                            this.context.delete(PDFRef.of(0));\n                        }\n                        return [2 /*return*/, this.context];\n                }\n            });\n        });\n    };\n    PDFParser.prototype.maybeRecoverRoot = function () {\n        var isValidCatalog = function (obj) {\n            return obj instanceof PDFDict &&\n                obj.lookup(PDFName.of('Type')) === PDFName.of('Catalog');\n        };\n        var catalog = this.context.lookup(this.context.trailerInfo.Root);\n        if (!isValidCatalog(catalog)) {\n            var indirectObjects = this.context.enumerateIndirectObjects();\n            for (var idx = 0, len = indirectObjects.length; idx < len; idx++) {\n                var _a = indirectObjects[idx], ref = _a[0], object = _a[1];\n                if (isValidCatalog(object)) {\n                    this.context.trailerInfo.Root = ref;\n                }\n            }\n        }\n    };\n    PDFParser.prototype.parseHeader = function () {\n        while (!this.bytes.done()) {\n            if (this.matchKeyword(Keywords.header)) {\n                var major = this.parseRawInt();\n                this.bytes.assertNext(CharCodes.Period);\n                var minor = this.parseRawInt();\n                var header = PDFHeader.forVersion(major, minor);\n                this.skipBinaryHeaderComment();\n                return header;\n            }\n            this.bytes.next();\n        }\n        throw new MissingPDFHeaderError(this.bytes.position());\n    };\n    PDFParser.prototype.parseIndirectObjectHeader = function () {\n        this.skipWhitespaceAndComments();\n        var objectNumber = this.parseRawInt();\n        this.skipWhitespaceAndComments();\n        var generationNumber = this.parseRawInt();\n        this.skipWhitespaceAndComments();\n        if (!this.matchKeyword(Keywords.obj)) {\n            throw new MissingKeywordError(this.bytes.position(), Keywords.obj);\n        }\n        return PDFRef.of(objectNumber, generationNumber);\n    };\n    PDFParser.prototype.matchIndirectObjectHeader = function () {\n        var initialOffset = this.bytes.offset();\n        try {\n            this.parseIndirectObjectHeader();\n            return true;\n        }\n        catch (e) {\n            this.bytes.moveTo(initialOffset);\n            return false;\n        }\n    };\n    PDFParser.prototype.parseIndirectObject = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var ref, object;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        ref = this.parseIndirectObjectHeader();\n                        this.skipWhitespaceAndComments();\n                        object = this.parseObject();\n                        this.skipWhitespaceAndComments();\n                        // if (!this.matchKeyword(Keywords.endobj)) {\n                        // throw new MissingKeywordError(this.bytes.position(), Keywords.endobj);\n                        // }\n                        // TODO: Log a warning if this fails...\n                        this.matchKeyword(Keywords.endobj);\n                        if (!(object instanceof PDFRawStream &&\n                            object.dict.lookup(PDFName.of('Type')) === PDFName.of('ObjStm'))) return [3 /*break*/, 2];\n                        return [4 /*yield*/, PDFObjectStreamParser.forStream(object, this.shouldWaitForTick).parseIntoContext()];\n                    case 1:\n                        _a.sent();\n                        return [3 /*break*/, 3];\n                    case 2:\n                        if (object instanceof PDFRawStream &&\n                            object.dict.lookup(PDFName.of('Type')) === PDFName.of('XRef')) {\n                            PDFXRefStreamParser.forStream(object).parseIntoContext();\n                        }\n                        else {\n                            this.context.assign(ref, object);\n                        }\n                        _a.label = 3;\n                    case 3: return [2 /*return*/, ref];\n                }\n            });\n        });\n    };\n    // TODO: Improve and clean this up\n    PDFParser.prototype.tryToParseInvalidIndirectObject = function () {\n        var startPos = this.bytes.position();\n        var msg = \"Trying to parse invalid object: \" + JSON.stringify(startPos) + \")\";\n        if (this.throwOnInvalidObject)\n            throw new Error(msg);\n        console.warn(msg);\n        var ref = this.parseIndirectObjectHeader();\n        console.warn(\"Invalid object ref: \" + ref);\n        this.skipWhitespaceAndComments();\n        var start = this.bytes.offset();\n        var failed = true;\n        while (!this.bytes.done()) {\n            if (this.matchKeyword(Keywords.endobj)) {\n                failed = false;\n            }\n            if (!failed)\n                break;\n            this.bytes.next();\n        }\n        if (failed)\n            throw new PDFInvalidObjectParsingError(startPos);\n        var end = this.bytes.offset() - Keywords.endobj.length;\n        var object = PDFInvalidObject.of(this.bytes.slice(start, end));\n        this.context.assign(ref, object);\n        return ref;\n    };\n    PDFParser.prototype.parseIndirectObjects = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var initialOffset, e_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.skipWhitespaceAndComments();\n                        _a.label = 1;\n                    case 1:\n                        if (!(!this.bytes.done() && IsDigit[this.bytes.peek()])) return [3 /*break*/, 8];\n                        initialOffset = this.bytes.offset();\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, this.parseIndirectObject()];\n                    case 3:\n                        _a.sent();\n                        return [3 /*break*/, 5];\n                    case 4:\n                        e_1 = _a.sent();\n                        // TODO: Add tracing/logging mechanism to track when this happens!\n                        this.bytes.moveTo(initialOffset);\n                        this.tryToParseInvalidIndirectObject();\n                        return [3 /*break*/, 5];\n                    case 5:\n                        this.skipWhitespaceAndComments();\n                        // TODO: Can this be done only when needed, to avoid harming performance?\n                        this.skipJibberish();\n                        if (!this.shouldWaitForTick()) return [3 /*break*/, 7];\n                        return [4 /*yield*/, waitForTick()];\n                    case 6:\n                        _a.sent();\n                        _a.label = 7;\n                    case 7: return [3 /*break*/, 1];\n                    case 8: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    PDFParser.prototype.maybeParseCrossRefSection = function () {\n        this.skipWhitespaceAndComments();\n        if (!this.matchKeyword(Keywords.xref))\n            return;\n        this.skipWhitespaceAndComments();\n        var objectNumber = -1;\n        var xref = PDFCrossRefSection.createEmpty();\n        while (!this.bytes.done() && IsDigit[this.bytes.peek()]) {\n            var firstInt = this.parseRawInt();\n            this.skipWhitespaceAndComments();\n            var secondInt = this.parseRawInt();\n            this.skipWhitespaceAndComments();\n            var byte = this.bytes.peek();\n            if (byte === CharCodes.n || byte === CharCodes.f) {\n                var ref = PDFRef.of(objectNumber, secondInt);\n                if (this.bytes.next() === CharCodes.n) {\n                    xref.addEntry(ref, firstInt);\n                }\n                else {\n                    // this.context.delete(ref);\n                    xref.addDeletedEntry(ref, firstInt);\n                }\n                objectNumber += 1;\n            }\n            else {\n                objectNumber = firstInt;\n            }\n            this.skipWhitespaceAndComments();\n        }\n        return xref;\n    };\n    PDFParser.prototype.maybeParseTrailerDict = function () {\n        this.skipWhitespaceAndComments();\n        if (!this.matchKeyword(Keywords.trailer))\n            return;\n        this.skipWhitespaceAndComments();\n        var dict = this.parseDict();\n        var context = this.context;\n        context.trailerInfo = {\n            Root: dict.get(PDFName.of('Root')) || context.trailerInfo.Root,\n            Encrypt: dict.get(PDFName.of('Encrypt')) || context.trailerInfo.Encrypt,\n            Info: dict.get(PDFName.of('Info')) || context.trailerInfo.Info,\n            ID: dict.get(PDFName.of('ID')) || context.trailerInfo.ID,\n        };\n    };\n    PDFParser.prototype.maybeParseTrailer = function () {\n        this.skipWhitespaceAndComments();\n        if (!this.matchKeyword(Keywords.startxref))\n            return;\n        this.skipWhitespaceAndComments();\n        var offset = this.parseRawInt();\n        this.skipWhitespace();\n        this.matchKeyword(Keywords.eof);\n        this.skipWhitespaceAndComments();\n        this.matchKeyword(Keywords.eof);\n        this.skipWhitespaceAndComments();\n        return PDFTrailer.forLastCrossRefSectionOffset(offset);\n    };\n    PDFParser.prototype.parseDocumentSection = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.parseIndirectObjects()];\n                    case 1:\n                        _a.sent();\n                        this.maybeParseCrossRefSection();\n                        this.maybeParseTrailerDict();\n                        this.maybeParseTrailer();\n                        // TODO: Can this be done only when needed, to avoid harming performance?\n                        this.skipJibberish();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * This operation is not necessary for valid PDF files. But some invalid PDFs\n     * contain jibberish in between indirect objects. This method is designed to\n     * skip past that jibberish, should it exist, until it reaches the next\n     * indirect object header, an xref table section, or the file trailer.\n     */\n    PDFParser.prototype.skipJibberish = function () {\n        this.skipWhitespaceAndComments();\n        while (!this.bytes.done()) {\n            var initialOffset = this.bytes.offset();\n            var byte = this.bytes.peek();\n            var isAlphaNumeric = byte >= CharCodes.Space && byte <= CharCodes.Tilde;\n            if (isAlphaNumeric) {\n                if (this.matchKeyword(Keywords.xref) ||\n                    this.matchKeyword(Keywords.trailer) ||\n                    this.matchKeyword(Keywords.startxref) ||\n                    this.matchIndirectObjectHeader()) {\n                    this.bytes.moveTo(initialOffset);\n                    break;\n                }\n            }\n            this.bytes.next();\n        }\n    };\n    /**\n     * Skips the binary comment following a PDF header. The specification\n     * defines this binary comment (section 7.5.2 File Header) as a sequence of 4\n     * or more bytes that are 128 or greater, and which are preceded by a \"%\".\n     *\n     * This would imply that to strip out this binary comment, we could check for\n     * a sequence of bytes starting with \"%\", and remove all subsequent bytes that\n     * are 128 or greater. This works for many documents that properly comply with\n     * the spec. But in the wild, there are PDFs that omit the leading \"%\", and\n     * include bytes that are less than 128 (e.g. 0 or 1). So in order to parse\n     * these headers correctly, we just throw out all bytes leading up to the\n     * first indirect object header.\n     */\n    PDFParser.prototype.skipBinaryHeaderComment = function () {\n        this.skipWhitespaceAndComments();\n        try {\n            var initialOffset = this.bytes.offset();\n            this.parseIndirectObjectHeader();\n            this.bytes.moveTo(initialOffset);\n        }\n        catch (e) {\n            this.bytes.next();\n            this.skipWhitespaceAndComments();\n        }\n    };\n    PDFParser.forBytesWithOptions = function (pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {\n        return new PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers);\n    };\n    return PDFParser;\n}(PDFObjectParser));\nexport default PDFParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}