{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport PDFCrossRefSection from \"../document/PDFCrossRefSection\";\nimport PDFHeader from \"../document/PDFHeader\";\nimport PDFTrailer from \"../document/PDFTrailer\";\nimport PDFTrailerDict from \"../document/PDFTrailerDict\";\nimport PDFObjectStream from \"../structures/PDFObjectStream\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { copyStringIntoBuffer, waitForTick } from \"../../utils\";\nvar PDFWriter = /** @class */function () {\n  function PDFWriter(context, objectsPerTick) {\n    var _this = this;\n    this.parsedObjects = 0;\n    this.shouldWaitForTick = function (n) {\n      _this.parsedObjects += n;\n      return _this.parsedObjects % _this.objectsPerTick === 0;\n    };\n    this.context = context;\n    this.objectsPerTick = objectsPerTick;\n  }\n  PDFWriter.prototype.serializeToBuffer = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, size, header, indirectObjects, xref, trailerDict, trailer, offset, buffer, idx, len, _b, ref, object, objectNumber, generationNumber, n;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            return [4 /*yield*/, this.computeBufferSize()];\n          case 1:\n            _a = _c.sent(), size = _a.size, header = _a.header, indirectObjects = _a.indirectObjects, xref = _a.xref, trailerDict = _a.trailerDict, trailer = _a.trailer;\n            offset = 0;\n            buffer = new Uint8Array(size);\n            offset += header.copyBytesInto(buffer, offset);\n            buffer[offset++] = CharCodes.Newline;\n            buffer[offset++] = CharCodes.Newline;\n            idx = 0, len = indirectObjects.length;\n            _c.label = 2;\n          case 2:\n            if (!(idx < len)) return [3 /*break*/, 5];\n            _b = indirectObjects[idx], ref = _b[0], object = _b[1];\n            objectNumber = String(ref.objectNumber);\n            offset += copyStringIntoBuffer(objectNumber, buffer, offset);\n            buffer[offset++] = CharCodes.Space;\n            generationNumber = String(ref.generationNumber);\n            offset += copyStringIntoBuffer(generationNumber, buffer, offset);\n            buffer[offset++] = CharCodes.Space;\n            buffer[offset++] = CharCodes.o;\n            buffer[offset++] = CharCodes.b;\n            buffer[offset++] = CharCodes.j;\n            buffer[offset++] = CharCodes.Newline;\n            offset += object.copyBytesInto(buffer, offset);\n            buffer[offset++] = CharCodes.Newline;\n            buffer[offset++] = CharCodes.e;\n            buffer[offset++] = CharCodes.n;\n            buffer[offset++] = CharCodes.d;\n            buffer[offset++] = CharCodes.o;\n            buffer[offset++] = CharCodes.b;\n            buffer[offset++] = CharCodes.j;\n            buffer[offset++] = CharCodes.Newline;\n            buffer[offset++] = CharCodes.Newline;\n            n = object instanceof PDFObjectStream ? object.getObjectsCount() : 1;\n            if (!this.shouldWaitForTick(n)) return [3 /*break*/, 4];\n            return [4 /*yield*/, waitForTick()];\n          case 3:\n            _c.sent();\n            _c.label = 4;\n          case 4:\n            idx++;\n            return [3 /*break*/, 2];\n          case 5:\n            if (xref) {\n              offset += xref.copyBytesInto(buffer, offset);\n              buffer[offset++] = CharCodes.Newline;\n            }\n            if (trailerDict) {\n              offset += trailerDict.copyBytesInto(buffer, offset);\n              buffer[offset++] = CharCodes.Newline;\n              buffer[offset++] = CharCodes.Newline;\n            }\n            offset += trailer.copyBytesInto(buffer, offset);\n            return [2 /*return*/, buffer];\n        }\n      });\n    });\n  };\n  PDFWriter.prototype.computeIndirectObjectSize = function (_a) {\n    var ref = _a[0],\n      object = _a[1];\n    var refSize = ref.sizeInBytes() + 3; // 'R' -> 'obj\\n'\n    var objectSize = object.sizeInBytes() + 9; // '\\nendobj\\n\\n'\n    return refSize + objectSize;\n  };\n  PDFWriter.prototype.createTrailerDict = function () {\n    return this.context.obj({\n      Size: this.context.largestObjectNumber + 1,\n      Root: this.context.trailerInfo.Root,\n      Encrypt: this.context.trailerInfo.Encrypt,\n      Info: this.context.trailerInfo.Info,\n      ID: this.context.trailerInfo.ID\n    });\n  };\n  PDFWriter.prototype.computeBufferSize = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var header, size, xref, indirectObjects, idx, len, indirectObject, ref, xrefOffset, trailerDict, trailer;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            header = PDFHeader.forVersion(1, 7);\n            size = header.sizeInBytes() + 2;\n            xref = PDFCrossRefSection.create();\n            indirectObjects = this.context.enumerateIndirectObjects();\n            idx = 0, len = indirectObjects.length;\n            _a.label = 1;\n          case 1:\n            if (!(idx < len)) return [3 /*break*/, 4];\n            indirectObject = indirectObjects[idx];\n            ref = indirectObject[0];\n            xref.addEntry(ref, size);\n            size += this.computeIndirectObjectSize(indirectObject);\n            if (!this.shouldWaitForTick(1)) return [3 /*break*/, 3];\n            return [4 /*yield*/, waitForTick()];\n          case 2:\n            _a.sent();\n            _a.label = 3;\n          case 3:\n            idx++;\n            return [3 /*break*/, 1];\n          case 4:\n            xrefOffset = size;\n            size += xref.sizeInBytes() + 1; // '\\n'\n            trailerDict = PDFTrailerDict.of(this.createTrailerDict());\n            size += trailerDict.sizeInBytes() + 2; // '\\n\\n'\n            trailer = PDFTrailer.forLastCrossRefSectionOffset(xrefOffset);\n            size += trailer.sizeInBytes();\n            return [2 /*return*/, {\n              size: size,\n              header: header,\n              indirectObjects: indirectObjects,\n              xref: xref,\n              trailerDict: trailerDict,\n              trailer: trailer\n            }];\n        }\n      });\n    });\n  };\n  PDFWriter.forContext = function (context, objectsPerTick) {\n    return new PDFWriter(context, objectsPerTick);\n  };\n  return PDFWriter;\n}();\nexport default PDFWriter;\n//# sourceMappingURL=PDFWriter.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}