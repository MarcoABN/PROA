{"ast":null,"code":"export var toCharCode = function (character) {\n  return character.charCodeAt(0);\n};\nexport var toCodePoint = function (character) {\n  return character.codePointAt(0);\n};\nexport var toHexStringOfMinLength = function (num, minLength) {\n  return padStart(num.toString(16), minLength, '0').toUpperCase();\n};\nexport var toHexString = function (num) {\n  return toHexStringOfMinLength(num, 2);\n};\nexport var charFromCode = function (code) {\n  return String.fromCharCode(code);\n};\nexport var charFromHexCode = function (hex) {\n  return charFromCode(parseInt(hex, 16));\n};\nexport var padStart = function (value, length, padChar) {\n  var padding = '';\n  for (var idx = 0, len = length - value.length; idx < len; idx++) {\n    padding += padChar;\n  }\n  return padding + value;\n};\nexport var copyStringIntoBuffer = function (str, buffer, offset) {\n  var length = str.length;\n  for (var idx = 0; idx < length; idx++) {\n    buffer[offset++] = str.charCodeAt(idx);\n  }\n  return length;\n};\nexport var addRandomSuffix = function (prefix, suffixLength) {\n  if (suffixLength === void 0) {\n    suffixLength = 4;\n  }\n  return prefix + \"-\" + Math.floor(Math.random() * Math.pow(10, suffixLength));\n};\nexport var escapeRegExp = function (str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n};\nexport var cleanText = function (text) {\n  return text.replace(/\\t|\\u0085|\\u2028|\\u2029/g, '    ').replace(/[\\b\\v]/g, '');\n};\nexport var escapedNewlineChars = ['\\\\n', '\\\\f', '\\\\r', '\\\\u000B'];\nexport var newlineChars = ['\\n', '\\f', '\\r', '\\u000B'];\nexport var isNewlineChar = function (text) {\n  return /^[\\n\\f\\r\\u000B]$/.test(text);\n};\nexport var lineSplit = function (text) {\n  return text.split(/[\\n\\f\\r\\u000B]/);\n};\nexport var mergeLines = function (text) {\n  return text.replace(/[\\n\\f\\r\\u000B]/g, ' ');\n};\n// JavaScript's String.charAt() method doesn work on strings containing UTF-16\n// characters (with high and low surrogate pairs), such as ðŸ’© (poo emoji). This\n// `charAtIndex()` function does.\n//\n// Credit: https://github.com/mathiasbynens/String.prototype.at/blob/master/at.js#L14-L48\nexport var charAtIndex = function (text, index) {\n  // Get the first code unit and code unit value\n  var cuFirst = text.charCodeAt(index);\n  var cuSecond;\n  var nextIndex = index + 1;\n  var length = 1;\n  if (\n  // Check if it's the start of a surrogate pair.\n  cuFirst >= 0xd800 && cuFirst <= 0xdbff &&\n  // high surrogate\n  text.length > nextIndex // there is a next code unit\n  ) {\n    cuSecond = text.charCodeAt(nextIndex);\n    if (cuSecond >= 0xdc00 && cuSecond <= 0xdfff) length = 2; // low surrogate\n  }\n\n  return [text.slice(index, index + length), length];\n};\nexport var charSplit = function (text) {\n  var chars = [];\n  for (var idx = 0, len = text.length; idx < len;) {\n    var _a = charAtIndex(text, idx),\n      c = _a[0],\n      cLen = _a[1];\n    chars.push(c);\n    idx += cLen;\n  }\n  return chars;\n};\nvar buildWordBreakRegex = function (wordBreaks) {\n  var newlineCharUnion = escapedNewlineChars.join('|');\n  var escapedRules = ['$'];\n  for (var idx = 0, len = wordBreaks.length; idx < len; idx++) {\n    var wordBreak = wordBreaks[idx];\n    if (isNewlineChar(wordBreak)) {\n      throw new TypeError(\"`wordBreak` must not include \" + newlineCharUnion);\n    }\n    escapedRules.push(wordBreak === '' ? '.' : escapeRegExp(wordBreak));\n  }\n  var breakRules = escapedRules.join('|');\n  return new RegExp(\"(\" + newlineCharUnion + \")|((.*?)(\" + breakRules + \"))\", 'gm');\n};\nexport var breakTextIntoLines = function (text, wordBreaks, maxWidth, computeWidthOfText) {\n  var regex = buildWordBreakRegex(wordBreaks);\n  var words = cleanText(text).match(regex);\n  var currLine = '';\n  var currWidth = 0;\n  var lines = [];\n  var pushCurrLine = function () {\n    if (currLine !== '') lines.push(currLine);\n    currLine = '';\n    currWidth = 0;\n  };\n  for (var idx = 0, len = words.length; idx < len; idx++) {\n    var word = words[idx];\n    if (isNewlineChar(word)) {\n      pushCurrLine();\n    } else {\n      var width = computeWidthOfText(word);\n      if (currWidth + width > maxWidth) pushCurrLine();\n      currLine += word;\n      currWidth += width;\n    }\n  }\n  pushCurrLine();\n  return lines;\n};\n// See section \"7.9.4 Dates\" of the PDF specification\nvar dateRegex = /^D:(\\d\\d\\d\\d)(\\d\\d)?(\\d\\d)?(\\d\\d)?(\\d\\d)?(\\d\\d)?([+\\-Z])?(\\d\\d)?'?(\\d\\d)?'?$/;\nexport var parseDate = function (dateStr) {\n  var match = dateStr.match(dateRegex);\n  if (!match) return undefined;\n  var year = match[1],\n    _a = match[2],\n    month = _a === void 0 ? '01' : _a,\n    _b = match[3],\n    day = _b === void 0 ? '01' : _b,\n    _c = match[4],\n    hours = _c === void 0 ? '00' : _c,\n    _d = match[5],\n    mins = _d === void 0 ? '00' : _d,\n    _e = match[6],\n    secs = _e === void 0 ? '00' : _e,\n    _f = match[7],\n    offsetSign = _f === void 0 ? 'Z' : _f,\n    _g = match[8],\n    offsetHours = _g === void 0 ? '00' : _g,\n    _h = match[9],\n    offsetMins = _h === void 0 ? '00' : _h;\n  // http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15\n  var tzOffset = offsetSign === 'Z' ? 'Z' : \"\" + offsetSign + offsetHours + \":\" + offsetMins;\n  var date = new Date(year + \"-\" + month + \"-\" + day + \"T\" + hours + \":\" + mins + \":\" + secs + tzOffset);\n  return date;\n};\nexport var findLastMatch = function (value, regex) {\n  var _a;\n  var position = 0;\n  var lastMatch;\n  while (position < value.length) {\n    var match = value.substring(position).match(regex);\n    if (!match) return {\n      match: lastMatch,\n      pos: position\n    };\n    lastMatch = match;\n    position += ((_a = match.index) !== null && _a !== void 0 ? _a : 0) + match[0].length;\n  }\n  return {\n    match: lastMatch,\n    pos: position\n  };\n};\n//# sourceMappingURL=strings.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}