{"ast":null,"code":"import { CombedTextLayoutError } from \"../errors\";\nimport { TextAlignment } from \"./alignment\";\nimport { cleanText, lineSplit, mergeLines, charAtIndex, charSplit } from \"../../utils\";\nvar MIN_FONT_SIZE = 4;\nvar MAX_FONT_SIZE = 500;\nvar computeFontSize = function (lines, font, bounds, multiline) {\n  if (multiline === void 0) {\n    multiline = false;\n  }\n  var fontSize = MIN_FONT_SIZE;\n  while (fontSize < MAX_FONT_SIZE) {\n    var linesUsed = 0;\n    for (var lineIdx = 0, lineLen = lines.length; lineIdx < lineLen; lineIdx++) {\n      linesUsed += 1;\n      var line = lines[lineIdx];\n      var words = line.split(' ');\n      // Layout the words using the current `fontSize`, line wrapping\n      // whenever we reach the end of the current line.\n      var spaceInLineRemaining = bounds.width;\n      for (var idx = 0, len = words.length; idx < len; idx++) {\n        var isLastWord = idx === len - 1;\n        var word = isLastWord ? words[idx] : words[idx] + ' ';\n        var widthOfWord = font.widthOfTextAtSize(word, fontSize);\n        spaceInLineRemaining -= widthOfWord;\n        if (spaceInLineRemaining <= 0) {\n          linesUsed += 1;\n          spaceInLineRemaining = bounds.width - widthOfWord;\n        }\n      }\n    }\n    // Return if we exceeded the allowed width\n    if (!multiline && linesUsed > lines.length) return fontSize - 1;\n    var height = font.heightAtSize(fontSize);\n    var lineHeight = height + height * 0.2;\n    var totalHeight = lineHeight * linesUsed;\n    // Return if we exceeded the allowed height\n    if (totalHeight > Math.abs(bounds.height)) return fontSize - 1;\n    fontSize += 1;\n  }\n  return fontSize;\n};\nvar computeCombedFontSize = function (line, font, bounds, cellCount) {\n  var cellWidth = bounds.width / cellCount;\n  var cellHeight = bounds.height;\n  var fontSize = MIN_FONT_SIZE;\n  var chars = charSplit(line);\n  while (fontSize < MAX_FONT_SIZE) {\n    for (var idx = 0, len = chars.length; idx < len; idx++) {\n      var c = chars[idx];\n      var tooLong = font.widthOfTextAtSize(c, fontSize) > cellWidth * 0.75;\n      if (tooLong) return fontSize - 1;\n    }\n    var height = font.heightAtSize(fontSize, {\n      descender: false\n    });\n    if (height > cellHeight) return fontSize - 1;\n    fontSize += 1;\n  }\n  return fontSize;\n};\nvar lastIndexOfWhitespace = function (line) {\n  for (var idx = line.length; idx > 0; idx--) {\n    if (/\\s/.test(line[idx])) return idx;\n  }\n  return undefined;\n};\nvar splitOutLines = function (input, maxWidth, font, fontSize) {\n  var _a;\n  var lastWhitespaceIdx = input.length;\n  while (lastWhitespaceIdx > 0) {\n    var line = input.substring(0, lastWhitespaceIdx);\n    var encoded = font.encodeText(line);\n    var width = font.widthOfTextAtSize(line, fontSize);\n    if (width < maxWidth) {\n      var remainder = input.substring(lastWhitespaceIdx) || undefined;\n      return {\n        line: line,\n        encoded: encoded,\n        width: width,\n        remainder: remainder\n      };\n    }\n    lastWhitespaceIdx = (_a = lastIndexOfWhitespace(line)) !== null && _a !== void 0 ? _a : 0;\n  }\n  // We were unable to split the input enough to get a chunk that would fit\n  // within the specified `maxWidth` so we'll just return everything\n  return {\n    line: input,\n    encoded: font.encodeText(input),\n    width: font.widthOfTextAtSize(input, fontSize),\n    remainder: undefined\n  };\n};\nexport var layoutMultilineText = function (text, _a) {\n  var alignment = _a.alignment,\n    fontSize = _a.fontSize,\n    font = _a.font,\n    bounds = _a.bounds;\n  var lines = lineSplit(cleanText(text));\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeFontSize(lines, font, bounds, true);\n  }\n  var height = font.heightAtSize(fontSize);\n  var lineHeight = height + height * 0.2;\n  var textLines = [];\n  var minX = bounds.x;\n  var minY = bounds.y;\n  var maxX = bounds.x + bounds.width;\n  var maxY = bounds.y + bounds.height;\n  var y = bounds.y + bounds.height;\n  for (var idx = 0, len = lines.length; idx < len; idx++) {\n    var prevRemainder = lines[idx];\n    while (prevRemainder !== undefined) {\n      var _b = splitOutLines(prevRemainder, bounds.width, font, fontSize),\n        line = _b.line,\n        encoded = _b.encoded,\n        width = _b.width,\n        remainder = _b.remainder;\n      // prettier-ignore\n      var x = alignment === TextAlignment.Left ? bounds.x : alignment === TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;\n      y -= lineHeight;\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (x + width > maxX) maxX = x + width;\n      if (y + height > maxY) maxY = y + height;\n      textLines.push({\n        text: line,\n        encoded: encoded,\n        width: width,\n        height: height,\n        x: x,\n        y: y\n      });\n      // Only trim lines that we had to split ourselves. So we won't trim lines\n      // that the user provided themselves with whitespace.\n      prevRemainder = remainder === null || remainder === void 0 ? void 0 : remainder.trim();\n    }\n  }\n  return {\n    fontSize: fontSize,\n    lineHeight: lineHeight,\n    lines: textLines,\n    bounds: {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  };\n};\nexport var layoutCombedText = function (text, _a) {\n  var fontSize = _a.fontSize,\n    font = _a.font,\n    bounds = _a.bounds,\n    cellCount = _a.cellCount;\n  var line = mergeLines(cleanText(text));\n  if (line.length > cellCount) {\n    throw new CombedTextLayoutError(line.length, cellCount);\n  }\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeCombedFontSize(line, font, bounds, cellCount);\n  }\n  var cellWidth = bounds.width / cellCount;\n  var height = font.heightAtSize(fontSize, {\n    descender: false\n  });\n  var y = bounds.y + (bounds.height / 2 - height / 2);\n  var cells = [];\n  var minX = bounds.x;\n  var minY = bounds.y;\n  var maxX = bounds.x + bounds.width;\n  var maxY = bounds.y + bounds.height;\n  var cellOffset = 0;\n  var charOffset = 0;\n  while (cellOffset < cellCount) {\n    var _b = charAtIndex(line, charOffset),\n      char = _b[0],\n      charLength = _b[1];\n    var encoded = font.encodeText(char);\n    var width = font.widthOfTextAtSize(char, fontSize);\n    var cellCenter = bounds.x + (cellWidth * cellOffset + cellWidth / 2);\n    var x = cellCenter - width / 2;\n    if (x < minX) minX = x;\n    if (y < minY) minY = y;\n    if (x + width > maxX) maxX = x + width;\n    if (y + height > maxY) maxY = y + height;\n    cells.push({\n      text: line,\n      encoded: encoded,\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    });\n    cellOffset += 1;\n    charOffset += charLength;\n  }\n  return {\n    fontSize: fontSize,\n    cells: cells,\n    bounds: {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  };\n};\nexport var layoutSinglelineText = function (text, _a) {\n  var alignment = _a.alignment,\n    fontSize = _a.fontSize,\n    font = _a.font,\n    bounds = _a.bounds;\n  var line = mergeLines(cleanText(text));\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeFontSize([line], font, bounds);\n  }\n  var encoded = font.encodeText(line);\n  var width = font.widthOfTextAtSize(line, fontSize);\n  var height = font.heightAtSize(fontSize, {\n    descender: false\n  });\n  // prettier-ignore\n  var x = alignment === TextAlignment.Left ? bounds.x : alignment === TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;\n  var y = bounds.y + (bounds.height / 2 - height / 2);\n  return {\n    fontSize: fontSize,\n    line: {\n      text: line,\n      encoded: encoded,\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    },\n    bounds: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  };\n};\n//# sourceMappingURL=layout.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}