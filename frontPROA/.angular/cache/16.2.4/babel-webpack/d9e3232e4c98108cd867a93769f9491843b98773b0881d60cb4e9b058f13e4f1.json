{"ast":null,"code":"import PDFArray from \"./objects/PDFArray\";\nimport PDFDict from \"./objects/PDFDict\";\nimport PDFName from \"./objects/PDFName\";\nimport PDFRef from \"./objects/PDFRef\";\nimport PDFStream from \"./objects/PDFStream\";\nimport PDFPageLeaf from \"./structures/PDFPageLeaf\";\n/**\n * PDFObjectCopier copies PDFObjects from a src context to a dest context.\n * The primary use case for this is to copy pages between PDFs.\n *\n * _Copying_ an object with a PDFObjectCopier is different from _cloning_ an\n * object with its [[PDFObject.clone]] method:\n *\n * ```\n *   const src: PDFContext = ...\n *   const dest: PDFContext = ...\n *   const originalObject: PDFObject = ...\n *   const copiedObject = PDFObjectCopier.for(src, dest).copy(originalObject);\n *   const clonedObject = originalObject.clone();\n * ```\n *\n * Copying an object is equivalent to cloning it and then copying over any other\n * objects that it references. Note that only dictionaries, arrays, and streams\n * (or structures build from them) can contain indirect references to other\n * objects. Copying a PDFObject that is not a dictionary, array, or stream is\n * supported, but is equivalent to cloning it.\n */\nvar PDFObjectCopier = /** @class */function () {\n  function PDFObjectCopier(src, dest) {\n    var _this = this;\n    this.traversedObjects = new Map();\n    // prettier-ignore\n    this.copy = function (object) {\n      return object instanceof PDFPageLeaf ? _this.copyPDFPage(object) : object instanceof PDFDict ? _this.copyPDFDict(object) : object instanceof PDFArray ? _this.copyPDFArray(object) : object instanceof PDFStream ? _this.copyPDFStream(object) : object instanceof PDFRef ? _this.copyPDFIndirectObject(object) : object.clone();\n    };\n    this.copyPDFPage = function (originalPage) {\n      var clonedPage = originalPage.clone();\n      // Move any entries that the originalPage is inheriting from its parent\n      // tree nodes directly into originalPage so they are preserved during\n      // the copy.\n      var InheritableEntries = PDFPageLeaf.InheritableEntries;\n      for (var idx = 0, len = InheritableEntries.length; idx < len; idx++) {\n        var key = PDFName.of(InheritableEntries[idx]);\n        var value = clonedPage.getInheritableAttribute(key);\n        if (!clonedPage.get(key) && value) clonedPage.set(key, value);\n      }\n      // Remove the parent reference to prevent the whole donor document's page\n      // tree from being copied when we only need a single page.\n      clonedPage.delete(PDFName.of('Parent'));\n      return _this.copyPDFDict(clonedPage);\n    };\n    this.copyPDFDict = function (originalDict) {\n      if (_this.traversedObjects.has(originalDict)) {\n        return _this.traversedObjects.get(originalDict);\n      }\n      var clonedDict = originalDict.clone(_this.dest);\n      _this.traversedObjects.set(originalDict, clonedDict);\n      var entries = originalDict.entries();\n      for (var idx = 0, len = entries.length; idx < len; idx++) {\n        var _a = entries[idx],\n          key = _a[0],\n          value = _a[1];\n        clonedDict.set(key, _this.copy(value));\n      }\n      return clonedDict;\n    };\n    this.copyPDFArray = function (originalArray) {\n      if (_this.traversedObjects.has(originalArray)) {\n        return _this.traversedObjects.get(originalArray);\n      }\n      var clonedArray = originalArray.clone(_this.dest);\n      _this.traversedObjects.set(originalArray, clonedArray);\n      for (var idx = 0, len = originalArray.size(); idx < len; idx++) {\n        var value = originalArray.get(idx);\n        clonedArray.set(idx, _this.copy(value));\n      }\n      return clonedArray;\n    };\n    this.copyPDFStream = function (originalStream) {\n      if (_this.traversedObjects.has(originalStream)) {\n        return _this.traversedObjects.get(originalStream);\n      }\n      var clonedStream = originalStream.clone(_this.dest);\n      _this.traversedObjects.set(originalStream, clonedStream);\n      var entries = originalStream.dict.entries();\n      for (var idx = 0, len = entries.length; idx < len; idx++) {\n        var _a = entries[idx],\n          key = _a[0],\n          value = _a[1];\n        clonedStream.dict.set(key, _this.copy(value));\n      }\n      return clonedStream;\n    };\n    this.copyPDFIndirectObject = function (ref) {\n      var alreadyMapped = _this.traversedObjects.has(ref);\n      if (!alreadyMapped) {\n        var newRef = _this.dest.nextRef();\n        _this.traversedObjects.set(ref, newRef);\n        var dereferencedValue = _this.src.lookup(ref);\n        if (dereferencedValue) {\n          var cloned = _this.copy(dereferencedValue);\n          _this.dest.assign(newRef, cloned);\n        }\n      }\n      return _this.traversedObjects.get(ref);\n    };\n    this.src = src;\n    this.dest = dest;\n  }\n  PDFObjectCopier.for = function (src, dest) {\n    return new PDFObjectCopier(src, dest);\n  };\n  return PDFObjectCopier;\n}();\nexport default PDFObjectCopier;\n//# sourceMappingURL=PDFObjectCopier.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}