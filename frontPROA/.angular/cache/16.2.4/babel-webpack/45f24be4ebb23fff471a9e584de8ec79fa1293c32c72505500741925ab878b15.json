{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport PDFCrossRefSection from \"../document/PDFCrossRefSection\";\nimport PDFHeader from \"../document/PDFHeader\";\nimport PDFTrailer from \"../document/PDFTrailer\";\nimport { MissingKeywordError, MissingPDFHeaderError, PDFInvalidObjectParsingError, ReparseError, StalledParserError } from \"../errors\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFInvalidObject from \"../objects/PDFInvalidObject\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFRawStream from \"../objects/PDFRawStream\";\nimport PDFRef from \"../objects/PDFRef\";\nimport ByteStream from \"./ByteStream\";\nimport PDFObjectParser from \"./PDFObjectParser\";\nimport PDFObjectStreamParser from \"./PDFObjectStreamParser\";\nimport PDFXRefStreamParser from \"./PDFXRefStreamParser\";\nimport PDFContext from \"../PDFContext\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { Keywords } from \"../syntax/Keywords\";\nimport { IsDigit } from \"../syntax/Numeric\";\nimport { waitForTick } from \"../../utils\";\nvar PDFParser = /** @class */function (_super) {\n  __extends(PDFParser, _super);\n  function PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {\n    if (objectsPerTick === void 0) {\n      objectsPerTick = Infinity;\n    }\n    if (throwOnInvalidObject === void 0) {\n      throwOnInvalidObject = false;\n    }\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n    var _this = _super.call(this, ByteStream.of(pdfBytes), PDFContext.create(), capNumbers) || this;\n    _this.alreadyParsed = false;\n    _this.parsedObjects = 0;\n    _this.shouldWaitForTick = function () {\n      _this.parsedObjects += 1;\n      return _this.parsedObjects % _this.objectsPerTick === 0;\n    };\n    _this.objectsPerTick = objectsPerTick;\n    _this.throwOnInvalidObject = throwOnInvalidObject;\n    return _this;\n  }\n  PDFParser.prototype.parseDocument = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var prevOffset, offset;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.alreadyParsed) {\n              throw new ReparseError('PDFParser', 'parseDocument');\n            }\n            this.alreadyParsed = true;\n            this.context.header = this.parseHeader();\n            _a.label = 1;\n          case 1:\n            if (!!this.bytes.done()) return [3 /*break*/, 3];\n            return [4 /*yield*/, this.parseDocumentSection()];\n          case 2:\n            _a.sent();\n            offset = this.bytes.offset();\n            if (offset === prevOffset) {\n              throw new StalledParserError(this.bytes.position());\n            }\n            prevOffset = offset;\n            return [3 /*break*/, 1];\n          case 3:\n            this.maybeRecoverRoot();\n            if (this.context.lookup(PDFRef.of(0))) {\n              console.warn('Removing parsed object: 0 0 R');\n              this.context.delete(PDFRef.of(0));\n            }\n            return [2 /*return*/, this.context];\n        }\n      });\n    });\n  };\n  PDFParser.prototype.maybeRecoverRoot = function () {\n    var isValidCatalog = function (obj) {\n      return obj instanceof PDFDict && obj.lookup(PDFName.of('Type')) === PDFName.of('Catalog');\n    };\n    var catalog = this.context.lookup(this.context.trailerInfo.Root);\n    if (!isValidCatalog(catalog)) {\n      var indirectObjects = this.context.enumerateIndirectObjects();\n      for (var idx = 0, len = indirectObjects.length; idx < len; idx++) {\n        var _a = indirectObjects[idx],\n          ref = _a[0],\n          object = _a[1];\n        if (isValidCatalog(object)) {\n          this.context.trailerInfo.Root = ref;\n        }\n      }\n    }\n  };\n  PDFParser.prototype.parseHeader = function () {\n    while (!this.bytes.done()) {\n      if (this.matchKeyword(Keywords.header)) {\n        var major = this.parseRawInt();\n        this.bytes.assertNext(CharCodes.Period);\n        var minor = this.parseRawInt();\n        var header = PDFHeader.forVersion(major, minor);\n        this.skipBinaryHeaderComment();\n        return header;\n      }\n      this.bytes.next();\n    }\n    throw new MissingPDFHeaderError(this.bytes.position());\n  };\n  PDFParser.prototype.parseIndirectObjectHeader = function () {\n    this.skipWhitespaceAndComments();\n    var objectNumber = this.parseRawInt();\n    this.skipWhitespaceAndComments();\n    var generationNumber = this.parseRawInt();\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.obj)) {\n      throw new MissingKeywordError(this.bytes.position(), Keywords.obj);\n    }\n    return PDFRef.of(objectNumber, generationNumber);\n  };\n  PDFParser.prototype.matchIndirectObjectHeader = function () {\n    var initialOffset = this.bytes.offset();\n    try {\n      this.parseIndirectObjectHeader();\n      return true;\n    } catch (e) {\n      this.bytes.moveTo(initialOffset);\n      return false;\n    }\n  };\n  PDFParser.prototype.parseIndirectObject = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var ref, object;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            ref = this.parseIndirectObjectHeader();\n            this.skipWhitespaceAndComments();\n            object = this.parseObject();\n            this.skipWhitespaceAndComments();\n            // if (!this.matchKeyword(Keywords.endobj)) {\n            // throw new MissingKeywordError(this.bytes.position(), Keywords.endobj);\n            // }\n            // TODO: Log a warning if this fails...\n            this.matchKeyword(Keywords.endobj);\n            if (!(object instanceof PDFRawStream && object.dict.lookup(PDFName.of('Type')) === PDFName.of('ObjStm'))) return [3 /*break*/, 2];\n            return [4 /*yield*/, PDFObjectStreamParser.forStream(object, this.shouldWaitForTick).parseIntoContext()];\n          case 1:\n            _a.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            if (object instanceof PDFRawStream && object.dict.lookup(PDFName.of('Type')) === PDFName.of('XRef')) {\n              PDFXRefStreamParser.forStream(object).parseIntoContext();\n            } else {\n              this.context.assign(ref, object);\n            }\n            _a.label = 3;\n          case 3:\n            return [2 /*return*/, ref];\n        }\n      });\n    });\n  };\n  // TODO: Improve and clean this up\n  PDFParser.prototype.tryToParseInvalidIndirectObject = function () {\n    var startPos = this.bytes.position();\n    var msg = \"Trying to parse invalid object: \" + JSON.stringify(startPos) + \")\";\n    if (this.throwOnInvalidObject) throw new Error(msg);\n    console.warn(msg);\n    var ref = this.parseIndirectObjectHeader();\n    console.warn(\"Invalid object ref: \" + ref);\n    this.skipWhitespaceAndComments();\n    var start = this.bytes.offset();\n    var failed = true;\n    while (!this.bytes.done()) {\n      if (this.matchKeyword(Keywords.endobj)) {\n        failed = false;\n      }\n      if (!failed) break;\n      this.bytes.next();\n    }\n    if (failed) throw new PDFInvalidObjectParsingError(startPos);\n    var end = this.bytes.offset() - Keywords.endobj.length;\n    var object = PDFInvalidObject.of(this.bytes.slice(start, end));\n    this.context.assign(ref, object);\n    return ref;\n  };\n  PDFParser.prototype.parseIndirectObjects = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var initialOffset, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.skipWhitespaceAndComments();\n            _a.label = 1;\n          case 1:\n            if (!(!this.bytes.done() && IsDigit[this.bytes.peek()])) return [3 /*break*/, 8];\n            initialOffset = this.bytes.offset();\n            _a.label = 2;\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n            return [4 /*yield*/, this.parseIndirectObject()];\n          case 3:\n            _a.sent();\n            return [3 /*break*/, 5];\n          case 4:\n            e_1 = _a.sent();\n            // TODO: Add tracing/logging mechanism to track when this happens!\n            this.bytes.moveTo(initialOffset);\n            this.tryToParseInvalidIndirectObject();\n            return [3 /*break*/, 5];\n          case 5:\n            this.skipWhitespaceAndComments();\n            // TODO: Can this be done only when needed, to avoid harming performance?\n            this.skipJibberish();\n            if (!this.shouldWaitForTick()) return [3 /*break*/, 7];\n            return [4 /*yield*/, waitForTick()];\n          case 6:\n            _a.sent();\n            _a.label = 7;\n          case 7:\n            return [3 /*break*/, 1];\n          case 8:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  PDFParser.prototype.maybeParseCrossRefSection = function () {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.xref)) return;\n    this.skipWhitespaceAndComments();\n    var objectNumber = -1;\n    var xref = PDFCrossRefSection.createEmpty();\n    while (!this.bytes.done() && IsDigit[this.bytes.peek()]) {\n      var firstInt = this.parseRawInt();\n      this.skipWhitespaceAndComments();\n      var secondInt = this.parseRawInt();\n      this.skipWhitespaceAndComments();\n      var byte = this.bytes.peek();\n      if (byte === CharCodes.n || byte === CharCodes.f) {\n        var ref = PDFRef.of(objectNumber, secondInt);\n        if (this.bytes.next() === CharCodes.n) {\n          xref.addEntry(ref, firstInt);\n        } else {\n          // this.context.delete(ref);\n          xref.addDeletedEntry(ref, firstInt);\n        }\n        objectNumber += 1;\n      } else {\n        objectNumber = firstInt;\n      }\n      this.skipWhitespaceAndComments();\n    }\n    return xref;\n  };\n  PDFParser.prototype.maybeParseTrailerDict = function () {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.trailer)) return;\n    this.skipWhitespaceAndComments();\n    var dict = this.parseDict();\n    var context = this.context;\n    context.trailerInfo = {\n      Root: dict.get(PDFName.of('Root')) || context.trailerInfo.Root,\n      Encrypt: dict.get(PDFName.of('Encrypt')) || context.trailerInfo.Encrypt,\n      Info: dict.get(PDFName.of('Info')) || context.trailerInfo.Info,\n      ID: dict.get(PDFName.of('ID')) || context.trailerInfo.ID\n    };\n  };\n  PDFParser.prototype.maybeParseTrailer = function () {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.startxref)) return;\n    this.skipWhitespaceAndComments();\n    var offset = this.parseRawInt();\n    this.skipWhitespace();\n    this.matchKeyword(Keywords.eof);\n    this.skipWhitespaceAndComments();\n    this.matchKeyword(Keywords.eof);\n    this.skipWhitespaceAndComments();\n    return PDFTrailer.forLastCrossRefSectionOffset(offset);\n  };\n  PDFParser.prototype.parseDocumentSection = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.parseIndirectObjects()];\n          case 1:\n            _a.sent();\n            this.maybeParseCrossRefSection();\n            this.maybeParseTrailerDict();\n            this.maybeParseTrailer();\n            // TODO: Can this be done only when needed, to avoid harming performance?\n            this.skipJibberish();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * This operation is not necessary for valid PDF files. But some invalid PDFs\n   * contain jibberish in between indirect objects. This method is designed to\n   * skip past that jibberish, should it exist, until it reaches the next\n   * indirect object header, an xref table section, or the file trailer.\n   */\n  PDFParser.prototype.skipJibberish = function () {\n    this.skipWhitespaceAndComments();\n    while (!this.bytes.done()) {\n      var initialOffset = this.bytes.offset();\n      var byte = this.bytes.peek();\n      var isAlphaNumeric = byte >= CharCodes.Space && byte <= CharCodes.Tilde;\n      if (isAlphaNumeric) {\n        if (this.matchKeyword(Keywords.xref) || this.matchKeyword(Keywords.trailer) || this.matchKeyword(Keywords.startxref) || this.matchIndirectObjectHeader()) {\n          this.bytes.moveTo(initialOffset);\n          break;\n        }\n      }\n      this.bytes.next();\n    }\n  };\n  /**\n   * Skips the binary comment following a PDF header. The specification\n   * defines this binary comment (section 7.5.2 File Header) as a sequence of 4\n   * or more bytes that are 128 or greater, and which are preceded by a \"%\".\n   *\n   * This would imply that to strip out this binary comment, we could check for\n   * a sequence of bytes starting with \"%\", and remove all subsequent bytes that\n   * are 128 or greater. This works for many documents that properly comply with\n   * the spec. But in the wild, there are PDFs that omit the leading \"%\", and\n   * include bytes that are less than 128 (e.g. 0 or 1). So in order to parse\n   * these headers correctly, we just throw out all bytes leading up to the\n   * first indirect object header.\n   */\n  PDFParser.prototype.skipBinaryHeaderComment = function () {\n    this.skipWhitespaceAndComments();\n    try {\n      var initialOffset = this.bytes.offset();\n      this.parseIndirectObjectHeader();\n      this.bytes.moveTo(initialOffset);\n    } catch (e) {\n      this.bytes.next();\n      this.skipWhitespaceAndComments();\n    }\n  };\n  PDFParser.forBytesWithOptions = function (pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {\n    return new PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers);\n  };\n  return PDFParser;\n}(PDFObjectParser);\nexport default PDFParser;\n//# sourceMappingURL=PDFParser.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}