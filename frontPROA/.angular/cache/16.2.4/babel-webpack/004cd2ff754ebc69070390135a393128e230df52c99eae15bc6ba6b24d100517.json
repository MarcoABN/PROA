{"ast":null,"code":"import { __assign } from \"tslib\";\nimport pako from 'pako';\nimport PDFHeader from \"./document/PDFHeader\";\nimport { UnexpectedObjectTypeError } from \"./errors\";\nimport PDFArray from \"./objects/PDFArray\";\nimport PDFBool from \"./objects/PDFBool\";\nimport PDFDict from \"./objects/PDFDict\";\nimport PDFName from \"./objects/PDFName\";\nimport PDFNull from \"./objects/PDFNull\";\nimport PDFNumber from \"./objects/PDFNumber\";\nimport PDFObject from \"./objects/PDFObject\";\nimport PDFRawStream from \"./objects/PDFRawStream\";\nimport PDFRef from \"./objects/PDFRef\";\nimport PDFOperator from \"./operators/PDFOperator\";\nimport Ops from \"./operators/PDFOperatorNames\";\nimport PDFContentStream from \"./structures/PDFContentStream\";\nimport { typedArrayFor } from \"../utils\";\nimport { SimpleRNG } from \"../utils/rng\";\nvar byAscendingObjectNumber = function (_a, _b) {\n  var a = _a[0];\n  var b = _b[0];\n  return a.objectNumber - b.objectNumber;\n};\nvar PDFContext = /** @class */function () {\n  function PDFContext() {\n    this.largestObjectNumber = 0;\n    this.header = PDFHeader.forVersion(1, 7);\n    this.trailerInfo = {};\n    this.indirectObjects = new Map();\n    this.rng = SimpleRNG.withSeed(1);\n  }\n  PDFContext.prototype.assign = function (ref, object) {\n    this.indirectObjects.set(ref, object);\n    if (ref.objectNumber > this.largestObjectNumber) {\n      this.largestObjectNumber = ref.objectNumber;\n    }\n  };\n  PDFContext.prototype.nextRef = function () {\n    this.largestObjectNumber += 1;\n    return PDFRef.of(this.largestObjectNumber);\n  };\n  PDFContext.prototype.register = function (object) {\n    var ref = this.nextRef();\n    this.assign(ref, object);\n    return ref;\n  };\n  PDFContext.prototype.delete = function (ref) {\n    return this.indirectObjects.delete(ref);\n  };\n  PDFContext.prototype.lookupMaybe = function (ref) {\n    var types = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      types[_i - 1] = arguments[_i];\n    }\n    // TODO: `preservePDFNull` is for backwards compatibility. Should be\n    // removed in next breaking API change.\n    var preservePDFNull = types.includes(PDFNull);\n    var result = ref instanceof PDFRef ? this.indirectObjects.get(ref) : ref;\n    if (!result || result === PDFNull && !preservePDFNull) return undefined;\n    for (var idx = 0, len = types.length; idx < len; idx++) {\n      var type = types[idx];\n      if (type === PDFNull) {\n        if (result === PDFNull) return result;\n      } else {\n        if (result instanceof type) return result;\n      }\n    }\n    throw new UnexpectedObjectTypeError(types, result);\n  };\n  PDFContext.prototype.lookup = function (ref) {\n    var types = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      types[_i - 1] = arguments[_i];\n    }\n    var result = ref instanceof PDFRef ? this.indirectObjects.get(ref) : ref;\n    if (types.length === 0) return result;\n    for (var idx = 0, len = types.length; idx < len; idx++) {\n      var type = types[idx];\n      if (type === PDFNull) {\n        if (result === PDFNull) return result;\n      } else {\n        if (result instanceof type) return result;\n      }\n    }\n    throw new UnexpectedObjectTypeError(types, result);\n  };\n  PDFContext.prototype.getObjectRef = function (pdfObject) {\n    var entries = Array.from(this.indirectObjects.entries());\n    for (var idx = 0, len = entries.length; idx < len; idx++) {\n      var _a = entries[idx],\n        ref = _a[0],\n        object = _a[1];\n      if (object === pdfObject) {\n        return ref;\n      }\n    }\n    return undefined;\n  };\n  PDFContext.prototype.enumerateIndirectObjects = function () {\n    return Array.from(this.indirectObjects.entries()).sort(byAscendingObjectNumber);\n  };\n  PDFContext.prototype.obj = function (literal) {\n    if (literal instanceof PDFObject) {\n      return literal;\n    } else if (literal === null || literal === undefined) {\n      return PDFNull;\n    } else if (typeof literal === 'string') {\n      return PDFName.of(literal);\n    } else if (typeof literal === 'number') {\n      return PDFNumber.of(literal);\n    } else if (typeof literal === 'boolean') {\n      return literal ? PDFBool.True : PDFBool.False;\n    } else if (Array.isArray(literal)) {\n      var array = PDFArray.withContext(this);\n      for (var idx = 0, len = literal.length; idx < len; idx++) {\n        array.push(this.obj(literal[idx]));\n      }\n      return array;\n    } else {\n      var dict = PDFDict.withContext(this);\n      var keys = Object.keys(literal);\n      for (var idx = 0, len = keys.length; idx < len; idx++) {\n        var key = keys[idx];\n        var value = literal[key];\n        if (value !== undefined) dict.set(PDFName.of(key), this.obj(value));\n      }\n      return dict;\n    }\n  };\n  PDFContext.prototype.stream = function (contents, dict) {\n    if (dict === void 0) {\n      dict = {};\n    }\n    return PDFRawStream.of(this.obj(dict), typedArrayFor(contents));\n  };\n  PDFContext.prototype.flateStream = function (contents, dict) {\n    if (dict === void 0) {\n      dict = {};\n    }\n    return this.stream(pako.deflate(typedArrayFor(contents)), __assign(__assign({}, dict), {\n      Filter: 'FlateDecode'\n    }));\n  };\n  PDFContext.prototype.contentStream = function (operators, dict) {\n    if (dict === void 0) {\n      dict = {};\n    }\n    return PDFContentStream.of(this.obj(dict), operators);\n  };\n  PDFContext.prototype.formXObject = function (operators, dict) {\n    if (dict === void 0) {\n      dict = {};\n    }\n    return this.contentStream(operators, __assign(__assign({\n      BBox: this.obj([0, 0, 0, 0]),\n      Matrix: this.obj([1, 0, 0, 1, 0, 0])\n    }, dict), {\n      Type: 'XObject',\n      Subtype: 'Form'\n    }));\n  };\n  /*\n   * Reference to PDFContentStream that contains a single PDFOperator: `q`.\n   * Used by [[PDFPageLeaf]] instances to ensure that when content streams are\n   * added to a modified PDF, they start in the default, unchanged graphics\n   * state.\n   */\n  PDFContext.prototype.getPushGraphicsStateContentStream = function () {\n    if (this.pushGraphicsStateContentStreamRef) {\n      return this.pushGraphicsStateContentStreamRef;\n    }\n    var dict = this.obj({});\n    var op = PDFOperator.of(Ops.PushGraphicsState);\n    var stream = PDFContentStream.of(dict, [op]);\n    this.pushGraphicsStateContentStreamRef = this.register(stream);\n    return this.pushGraphicsStateContentStreamRef;\n  };\n  /*\n   * Reference to PDFContentStream that contains a single PDFOperator: `Q`.\n   * Used by [[PDFPageLeaf]] instances to ensure that when content streams are\n   * added to a modified PDF, they start in the default, unchanged graphics\n   * state.\n   */\n  PDFContext.prototype.getPopGraphicsStateContentStream = function () {\n    if (this.popGraphicsStateContentStreamRef) {\n      return this.popGraphicsStateContentStreamRef;\n    }\n    var dict = this.obj({});\n    var op = PDFOperator.of(Ops.PopGraphicsState);\n    var stream = PDFContentStream.of(dict, [op]);\n    this.popGraphicsStateContentStreamRef = this.register(stream);\n    return this.popGraphicsStateContentStreamRef;\n  };\n  PDFContext.prototype.addRandomSuffix = function (prefix, suffixLength) {\n    if (suffixLength === void 0) {\n      suffixLength = 4;\n    }\n    return prefix + \"-\" + Math.floor(this.rng.nextInt() * Math.pow(10, suffixLength));\n  };\n  PDFContext.create = function () {\n    return new PDFContext();\n  };\n  return PDFContext;\n}();\nexport default PDFContext;\n//# sourceMappingURL=PDFContext.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}