{"ast":null,"code":"import { CombedTextLayoutError } from \"../errors\";\nimport { TextAlignment } from \"./alignment\";\nimport { cleanText, lineSplit, mergeLines, charAtIndex, charSplit } from \"../../utils\";\nvar MIN_FONT_SIZE = 4;\nvar MAX_FONT_SIZE = 500;\nvar computeFontSize = function (lines, font, bounds, multiline) {\n  if (multiline === void 0) {\n    multiline = false;\n  }\n  var fontSize = MIN_FONT_SIZE;\n  while (fontSize < MAX_FONT_SIZE) {\n    var linesUsed = 0;\n    for (var lineIdx = 0, lineLen = lines.length; lineIdx < lineLen; lineIdx++) {\n      linesUsed += 1;\n      var line = lines[lineIdx];\n      var words = line.split(' ');\n      // Layout the words using the current `fontSize`, line wrapping\n      // whenever we reach the end of the current line.\n      var spaceInLineRemaining = bounds.width;\n      for (var idx = 0, len = words.length; idx < len; idx++) {\n        var isLastWord = idx === len - 1;\n        var word = isLastWord ? words[idx] : words[idx] + ' ';\n        var widthOfWord = font.widthOfTextAtSize(word, fontSize);\n        spaceInLineRemaining -= widthOfWord;\n        if (spaceInLineRemaining <= 0) {\n          linesUsed += 1;\n          spaceInLineRemaining = bounds.width - widthOfWord;\n        }\n      }\n    }\n    // Return if we exceeded the allowed width\n    if (!multiline && linesUsed > lines.length) return fontSize - 1;\n    var height = font.heightAtSize(fontSize);\n    var lineHeight = height + height * 0.2;\n    var totalHeight = lineHeight * linesUsed;\n    // Return if we exceeded the allowed height\n    if (totalHeight > Math.abs(bounds.height)) return fontSize - 1;\n    fontSize += 1;\n  }\n  return fontSize;\n};\nvar computeCombedFontSize = function (line, font, bounds, cellCount) {\n  var cellWidth = bounds.width / cellCount;\n  var cellHeight = bounds.height;\n  var fontSize = MIN_FONT_SIZE;\n  var chars = charSplit(line);\n  while (fontSize < MAX_FONT_SIZE) {\n    for (var idx = 0, len = chars.length; idx < len; idx++) {\n      var c = chars[idx];\n      var tooLong = font.widthOfTextAtSize(c, fontSize) > cellWidth * 0.75;\n      if (tooLong) return fontSize - 1;\n    }\n    var height = font.heightAtSize(fontSize, {\n      descender: false\n    });\n    if (height > cellHeight) return fontSize - 1;\n    fontSize += 1;\n  }\n  return fontSize;\n};\nvar lastIndexOfWhitespace = function (line) {\n  for (var idx = line.length; idx > 0; idx--) {\n    if (/\\s/.test(line[idx])) return idx;\n  }\n  return undefined;\n};\nvar splitOutLines = function (input, maxWidth, font, fontSize) {\n  var _a;\n  var lastWhitespaceIdx = input.length;\n  while (lastWhitespaceIdx > 0) {\n    var line = input.substring(0, lastWhitespaceIdx);\n    var encoded = font.encodeText(line);\n    var width = font.widthOfTextAtSize(line, fontSize);\n    if (width < maxWidth) {\n      var remainder = input.substring(lastWhitespaceIdx) || undefined;\n      return {\n        line: line,\n        encoded: encoded,\n        width: width,\n        remainder: remainder\n      };\n    }\n    lastWhitespaceIdx = (_a = lastIndexOfWhitespace(line)) !== null && _a !== void 0 ? _a : 0;\n  }\n  // We were unable to split the input enough to get a chunk that would fit\n  // within the specified `maxWidth` so we'll just return everything\n  return {\n    line: input,\n    encoded: font.encodeText(input),\n    width: font.widthOfTextAtSize(input, fontSize),\n    remainder: undefined\n  };\n};\nexport var layoutMultilineText = function (text, _a) {\n  var alignment = _a.alignment,\n    fontSize = _a.fontSize,\n    font = _a.font,\n    bounds = _a.bounds;\n  var lines = lineSplit(cleanText(text));\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeFontSize(lines, font, bounds, true);\n  }\n  var height = font.heightAtSize(fontSize);\n  var lineHeight = height + height * 0.2;\n  var textLines = [];\n  var minX = bounds.x;\n  var minY = bounds.y;\n  var maxX = bounds.x + bounds.width;\n  var maxY = bounds.y + bounds.height;\n  var y = bounds.y + bounds.height;\n  for (var idx = 0, len = lines.length; idx < len; idx++) {\n    var prevRemainder = lines[idx];\n    while (prevRemainder !== undefined) {\n      var _b = splitOutLines(prevRemainder, bounds.width, font, fontSize),\n        line = _b.line,\n        encoded = _b.encoded,\n        width = _b.width,\n        remainder = _b.remainder;\n      // prettier-ignore\n      var x = alignment === TextAlignment.Left ? bounds.x : alignment === TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;\n      y -= lineHeight;\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (x + width > maxX) maxX = x + width;\n      if (y + height > maxY) maxY = y + height;\n      textLines.push({\n        text: line,\n        encoded: encoded,\n        width: width,\n        height: height,\n        x: x,\n        y: y\n      });\n      // Only trim lines that we had to split ourselves. So we won't trim lines\n      // that the user provided themselves with whitespace.\n      prevRemainder = remainder === null || remainder === void 0 ? void 0 : remainder.trim();\n    }\n  }\n  return {\n    fontSize: fontSize,\n    lineHeight: lineHeight,\n    lines: textLines,\n    bounds: {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  };\n};\nexport var layoutCombedText = function (text, _a) {\n  var fontSize = _a.fontSize,\n    font = _a.font,\n    bounds = _a.bounds,\n    cellCount = _a.cellCount;\n  var line = mergeLines(cleanText(text));\n  if (line.length > cellCount) {\n    throw new CombedTextLayoutError(line.length, cellCount);\n  }\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeCombedFontSize(line, font, bounds, cellCount);\n  }\n  var cellWidth = bounds.width / cellCount;\n  var height = font.heightAtSize(fontSize, {\n    descender: false\n  });\n  var y = bounds.y + (bounds.height / 2 - height / 2);\n  var cells = [];\n  var minX = bounds.x;\n  var minY = bounds.y;\n  var maxX = bounds.x + bounds.width;\n  var maxY = bounds.y + bounds.height;\n  var cellOffset = 0;\n  var charOffset = 0;\n  while (cellOffset < cellCount) {\n    var _b = charAtIndex(line, charOffset),\n      char = _b[0],\n      charLength = _b[1];\n    var encoded = font.encodeText(char);\n    var width = font.widthOfTextAtSize(char, fontSize);\n    var cellCenter = bounds.x + (cellWidth * cellOffset + cellWidth / 2);\n    var x = cellCenter - width / 2;\n    if (x < minX) minX = x;\n    if (y < minY) minY = y;\n    if (x + width > maxX) maxX = x + width;\n    if (y + height > maxY) maxY = y + height;\n    cells.push({\n      text: line,\n      encoded: encoded,\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    });\n    cellOffset += 1;\n    charOffset += charLength;\n  }\n  return {\n    fontSize: fontSize,\n    cells: cells,\n    bounds: {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  };\n};\nexport var layoutSinglelineText = function (text, _a) {\n  var alignment = _a.alignment,\n    fontSize = _a.fontSize,\n    font = _a.font,\n    bounds = _a.bounds;\n  var line = mergeLines(cleanText(text));\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeFontSize([line], font, bounds);\n  }\n  var encoded = font.encodeText(line);\n  var width = font.widthOfTextAtSize(line, fontSize);\n  var height = font.heightAtSize(fontSize, {\n    descender: false\n  });\n  // prettier-ignore\n  var x = alignment === TextAlignment.Left ? bounds.x : alignment === TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;\n  var y = bounds.y + (bounds.height / 2 - height / 2);\n  return {\n    fontSize: fontSize,\n    line: {\n      text: line,\n      encoded: encoded,\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    },\n    bounds: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  };\n};","map":{"version":3,"names":["CombedTextLayoutError","TextAlignment","cleanText","lineSplit","mergeLines","charAtIndex","charSplit","MIN_FONT_SIZE","MAX_FONT_SIZE","computeFontSize","lines","font","bounds","multiline","fontSize","linesUsed","lineIdx","lineLen","length","line","words","split","spaceInLineRemaining","width","idx","len","isLastWord","word","widthOfWord","widthOfTextAtSize","height","heightAtSize","lineHeight","totalHeight","Math","abs","computeCombedFontSize","cellCount","cellWidth","cellHeight","chars","c","tooLong","descender","lastIndexOfWhitespace","test","undefined","splitOutLines","input","maxWidth","_a","lastWhitespaceIdx","substring","encoded","encodeText","remainder","layoutMultilineText","text","alignment","textLines","minX","x","minY","y","maxX","maxY","prevRemainder","_b","Left","Center","Right","push","trim","layoutCombedText","cells","cellOffset","charOffset","char","charLength","cellCenter","layoutSinglelineText"],"sources":["E:/PROA/frontPROA/node_modules/pdf-lib/es/api/text/layout.js"],"sourcesContent":["import { CombedTextLayoutError } from \"../errors\";\nimport { TextAlignment } from \"./alignment\";\nimport { cleanText, lineSplit, mergeLines, charAtIndex, charSplit, } from \"../../utils\";\nvar MIN_FONT_SIZE = 4;\nvar MAX_FONT_SIZE = 500;\nvar computeFontSize = function (lines, font, bounds, multiline) {\n    if (multiline === void 0) { multiline = false; }\n    var fontSize = MIN_FONT_SIZE;\n    while (fontSize < MAX_FONT_SIZE) {\n        var linesUsed = 0;\n        for (var lineIdx = 0, lineLen = lines.length; lineIdx < lineLen; lineIdx++) {\n            linesUsed += 1;\n            var line = lines[lineIdx];\n            var words = line.split(' ');\n            // Layout the words using the current `fontSize`, line wrapping\n            // whenever we reach the end of the current line.\n            var spaceInLineRemaining = bounds.width;\n            for (var idx = 0, len = words.length; idx < len; idx++) {\n                var isLastWord = idx === len - 1;\n                var word = isLastWord ? words[idx] : words[idx] + ' ';\n                var widthOfWord = font.widthOfTextAtSize(word, fontSize);\n                spaceInLineRemaining -= widthOfWord;\n                if (spaceInLineRemaining <= 0) {\n                    linesUsed += 1;\n                    spaceInLineRemaining = bounds.width - widthOfWord;\n                }\n            }\n        }\n        // Return if we exceeded the allowed width\n        if (!multiline && linesUsed > lines.length)\n            return fontSize - 1;\n        var height = font.heightAtSize(fontSize);\n        var lineHeight = height + height * 0.2;\n        var totalHeight = lineHeight * linesUsed;\n        // Return if we exceeded the allowed height\n        if (totalHeight > Math.abs(bounds.height))\n            return fontSize - 1;\n        fontSize += 1;\n    }\n    return fontSize;\n};\nvar computeCombedFontSize = function (line, font, bounds, cellCount) {\n    var cellWidth = bounds.width / cellCount;\n    var cellHeight = bounds.height;\n    var fontSize = MIN_FONT_SIZE;\n    var chars = charSplit(line);\n    while (fontSize < MAX_FONT_SIZE) {\n        for (var idx = 0, len = chars.length; idx < len; idx++) {\n            var c = chars[idx];\n            var tooLong = font.widthOfTextAtSize(c, fontSize) > cellWidth * 0.75;\n            if (tooLong)\n                return fontSize - 1;\n        }\n        var height = font.heightAtSize(fontSize, { descender: false });\n        if (height > cellHeight)\n            return fontSize - 1;\n        fontSize += 1;\n    }\n    return fontSize;\n};\nvar lastIndexOfWhitespace = function (line) {\n    for (var idx = line.length; idx > 0; idx--) {\n        if (/\\s/.test(line[idx]))\n            return idx;\n    }\n    return undefined;\n};\nvar splitOutLines = function (input, maxWidth, font, fontSize) {\n    var _a;\n    var lastWhitespaceIdx = input.length;\n    while (lastWhitespaceIdx > 0) {\n        var line = input.substring(0, lastWhitespaceIdx);\n        var encoded = font.encodeText(line);\n        var width = font.widthOfTextAtSize(line, fontSize);\n        if (width < maxWidth) {\n            var remainder = input.substring(lastWhitespaceIdx) || undefined;\n            return { line: line, encoded: encoded, width: width, remainder: remainder };\n        }\n        lastWhitespaceIdx = (_a = lastIndexOfWhitespace(line)) !== null && _a !== void 0 ? _a : 0;\n    }\n    // We were unable to split the input enough to get a chunk that would fit\n    // within the specified `maxWidth` so we'll just return everything\n    return {\n        line: input,\n        encoded: font.encodeText(input),\n        width: font.widthOfTextAtSize(input, fontSize),\n        remainder: undefined,\n    };\n};\nexport var layoutMultilineText = function (text, _a) {\n    var alignment = _a.alignment, fontSize = _a.fontSize, font = _a.font, bounds = _a.bounds;\n    var lines = lineSplit(cleanText(text));\n    if (fontSize === undefined || fontSize === 0) {\n        fontSize = computeFontSize(lines, font, bounds, true);\n    }\n    var height = font.heightAtSize(fontSize);\n    var lineHeight = height + height * 0.2;\n    var textLines = [];\n    var minX = bounds.x;\n    var minY = bounds.y;\n    var maxX = bounds.x + bounds.width;\n    var maxY = bounds.y + bounds.height;\n    var y = bounds.y + bounds.height;\n    for (var idx = 0, len = lines.length; idx < len; idx++) {\n        var prevRemainder = lines[idx];\n        while (prevRemainder !== undefined) {\n            var _b = splitOutLines(prevRemainder, bounds.width, font, fontSize), line = _b.line, encoded = _b.encoded, width = _b.width, remainder = _b.remainder;\n            // prettier-ignore\n            var x = (alignment === TextAlignment.Left ? bounds.x\n                : alignment === TextAlignment.Center ? bounds.x + (bounds.width / 2) - (width / 2)\n                    : alignment === TextAlignment.Right ? bounds.x + bounds.width - width\n                        : bounds.x);\n            y -= lineHeight;\n            if (x < minX)\n                minX = x;\n            if (y < minY)\n                minY = y;\n            if (x + width > maxX)\n                maxX = x + width;\n            if (y + height > maxY)\n                maxY = y + height;\n            textLines.push({ text: line, encoded: encoded, width: width, height: height, x: x, y: y });\n            // Only trim lines that we had to split ourselves. So we won't trim lines\n            // that the user provided themselves with whitespace.\n            prevRemainder = remainder === null || remainder === void 0 ? void 0 : remainder.trim();\n        }\n    }\n    return {\n        fontSize: fontSize,\n        lineHeight: lineHeight,\n        lines: textLines,\n        bounds: {\n            x: minX,\n            y: minY,\n            width: maxX - minX,\n            height: maxY - minY,\n        },\n    };\n};\nexport var layoutCombedText = function (text, _a) {\n    var fontSize = _a.fontSize, font = _a.font, bounds = _a.bounds, cellCount = _a.cellCount;\n    var line = mergeLines(cleanText(text));\n    if (line.length > cellCount) {\n        throw new CombedTextLayoutError(line.length, cellCount);\n    }\n    if (fontSize === undefined || fontSize === 0) {\n        fontSize = computeCombedFontSize(line, font, bounds, cellCount);\n    }\n    var cellWidth = bounds.width / cellCount;\n    var height = font.heightAtSize(fontSize, { descender: false });\n    var y = bounds.y + (bounds.height / 2 - height / 2);\n    var cells = [];\n    var minX = bounds.x;\n    var minY = bounds.y;\n    var maxX = bounds.x + bounds.width;\n    var maxY = bounds.y + bounds.height;\n    var cellOffset = 0;\n    var charOffset = 0;\n    while (cellOffset < cellCount) {\n        var _b = charAtIndex(line, charOffset), char = _b[0], charLength = _b[1];\n        var encoded = font.encodeText(char);\n        var width = font.widthOfTextAtSize(char, fontSize);\n        var cellCenter = bounds.x + (cellWidth * cellOffset + cellWidth / 2);\n        var x = cellCenter - width / 2;\n        if (x < minX)\n            minX = x;\n        if (y < minY)\n            minY = y;\n        if (x + width > maxX)\n            maxX = x + width;\n        if (y + height > maxY)\n            maxY = y + height;\n        cells.push({ text: line, encoded: encoded, width: width, height: height, x: x, y: y });\n        cellOffset += 1;\n        charOffset += charLength;\n    }\n    return {\n        fontSize: fontSize,\n        cells: cells,\n        bounds: {\n            x: minX,\n            y: minY,\n            width: maxX - minX,\n            height: maxY - minY,\n        },\n    };\n};\nexport var layoutSinglelineText = function (text, _a) {\n    var alignment = _a.alignment, fontSize = _a.fontSize, font = _a.font, bounds = _a.bounds;\n    var line = mergeLines(cleanText(text));\n    if (fontSize === undefined || fontSize === 0) {\n        fontSize = computeFontSize([line], font, bounds);\n    }\n    var encoded = font.encodeText(line);\n    var width = font.widthOfTextAtSize(line, fontSize);\n    var height = font.heightAtSize(fontSize, { descender: false });\n    // prettier-ignore\n    var x = (alignment === TextAlignment.Left ? bounds.x\n        : alignment === TextAlignment.Center ? bounds.x + (bounds.width / 2) - (width / 2)\n            : alignment === TextAlignment.Right ? bounds.x + bounds.width - width\n                : bounds.x);\n    var y = bounds.y + (bounds.height / 2 - height / 2);\n    return {\n        fontSize: fontSize,\n        line: { text: line, encoded: encoded, width: width, height: height, x: x, y: y },\n        bounds: { x: x, y: y, width: width, height: height },\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}