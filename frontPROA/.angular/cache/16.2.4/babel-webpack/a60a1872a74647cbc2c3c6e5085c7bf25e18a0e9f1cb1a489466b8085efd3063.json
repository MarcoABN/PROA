{"ast":null,"code":"import { __extends } from \"tslib\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFPageLeaf from \"./PDFPageLeaf\";\nimport { InvalidTargetIndexError, CorruptPageTreeError } from \"../errors\";\nvar PDFPageTree = /** @class */function (_super) {\n  __extends(PDFPageTree, _super);\n  function PDFPageTree() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  PDFPageTree.prototype.Parent = function () {\n    return this.lookup(PDFName.of('Parent'));\n  };\n  PDFPageTree.prototype.Kids = function () {\n    return this.lookup(PDFName.of('Kids'), PDFArray);\n  };\n  PDFPageTree.prototype.Count = function () {\n    return this.lookup(PDFName.of('Count'), PDFNumber);\n  };\n  PDFPageTree.prototype.pushTreeNode = function (treeRef) {\n    var Kids = this.Kids();\n    Kids.push(treeRef);\n  };\n  PDFPageTree.prototype.pushLeafNode = function (leafRef) {\n    var Kids = this.Kids();\n    this.insertLeafKid(Kids.size(), leafRef);\n  };\n  /**\n   * Inserts the given ref as a leaf node of this page tree at the specified\n   * index (zero-based). Also increments the `Count` of each page tree in the\n   * hierarchy to accomodate the new page.\n   *\n   * Returns the ref of the PDFPageTree node into which `leafRef` was inserted,\n   * or `undefined` if it was inserted into the root node (the PDFPageTree upon\n   * which the method was first called).\n   */\n  PDFPageTree.prototype.insertLeafNode = function (leafRef, targetIndex) {\n    var Kids = this.Kids();\n    var Count = this.Count().asNumber();\n    if (targetIndex > Count) {\n      throw new InvalidTargetIndexError(targetIndex, Count);\n    }\n    var leafsRemainingUntilTarget = targetIndex;\n    for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n      if (leafsRemainingUntilTarget === 0) {\n        // Insert page and return\n        this.insertLeafKid(idx, leafRef);\n        return undefined;\n      }\n      var kidRef = Kids.get(idx);\n      var kid = this.context.lookup(kidRef);\n      if (kid instanceof PDFPageTree) {\n        if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\n          // Dig in\n          return kid.insertLeafNode(leafRef, leafsRemainingUntilTarget) || kidRef;\n        } else {\n          // Move on\n          leafsRemainingUntilTarget -= kid.Count().asNumber();\n        }\n      }\n      if (kid instanceof PDFPageLeaf) {\n        // Move on\n        leafsRemainingUntilTarget -= 1;\n      }\n    }\n    if (leafsRemainingUntilTarget === 0) {\n      // Insert page at the end and return\n      this.insertLeafKid(Kids.size(), leafRef);\n      return undefined;\n    }\n    // Should never get here if `targetIndex` is valid\n    throw new CorruptPageTreeError(targetIndex, 'insertLeafNode');\n  };\n  /**\n   * Removes the leaf node at the specified index (zero-based) from this page\n   * tree. Also decrements the `Count` of each page tree in the hierarchy to\n   * account for the removed page.\n   *\n   * If `prune` is true, then intermediate tree nodes will be removed from the\n   * tree if they contain 0 children after the leaf node is removed.\n   */\n  PDFPageTree.prototype.removeLeafNode = function (targetIndex, prune) {\n    if (prune === void 0) {\n      prune = true;\n    }\n    var Kids = this.Kids();\n    var Count = this.Count().asNumber();\n    if (targetIndex >= Count) {\n      throw new InvalidTargetIndexError(targetIndex, Count);\n    }\n    var leafsRemainingUntilTarget = targetIndex;\n    for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n      var kidRef = Kids.get(idx);\n      var kid = this.context.lookup(kidRef);\n      if (kid instanceof PDFPageTree) {\n        if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\n          // Dig in\n          kid.removeLeafNode(leafsRemainingUntilTarget, prune);\n          if (prune && kid.Kids().size() === 0) Kids.remove(idx);\n          return;\n        } else {\n          // Move on\n          leafsRemainingUntilTarget -= kid.Count().asNumber();\n        }\n      }\n      if (kid instanceof PDFPageLeaf) {\n        if (leafsRemainingUntilTarget === 0) {\n          // Remove page and return\n          this.removeKid(idx);\n          return;\n        } else {\n          // Move on\n          leafsRemainingUntilTarget -= 1;\n        }\n      }\n    }\n    // Should never get here if `targetIndex` is valid\n    throw new CorruptPageTreeError(targetIndex, 'removeLeafNode');\n  };\n  PDFPageTree.prototype.ascend = function (visitor) {\n    visitor(this);\n    var Parent = this.Parent();\n    if (Parent) Parent.ascend(visitor);\n  };\n  /** Performs a Post-Order traversal of this page tree */\n  PDFPageTree.prototype.traverse = function (visitor) {\n    var Kids = this.Kids();\n    for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n      var kidRef = Kids.get(idx);\n      var kid = this.context.lookup(kidRef);\n      if (kid instanceof PDFPageTree) kid.traverse(visitor);\n      visitor(kid, kidRef);\n    }\n  };\n  PDFPageTree.prototype.insertLeafKid = function (kidIdx, leafRef) {\n    var Kids = this.Kids();\n    this.ascend(function (node) {\n      var newCount = node.Count().asNumber() + 1;\n      node.set(PDFName.of('Count'), PDFNumber.of(newCount));\n    });\n    Kids.insert(kidIdx, leafRef);\n  };\n  PDFPageTree.prototype.removeKid = function (kidIdx) {\n    var Kids = this.Kids();\n    var kid = Kids.lookup(kidIdx);\n    if (kid instanceof PDFPageLeaf) {\n      this.ascend(function (node) {\n        var newCount = node.Count().asNumber() - 1;\n        node.set(PDFName.of('Count'), PDFNumber.of(newCount));\n      });\n    }\n    Kids.remove(kidIdx);\n  };\n  PDFPageTree.withContext = function (context, parent) {\n    var dict = new Map();\n    dict.set(PDFName.of('Type'), PDFName.of('Pages'));\n    dict.set(PDFName.of('Kids'), context.obj([]));\n    dict.set(PDFName.of('Count'), context.obj(0));\n    if (parent) dict.set(PDFName.of('Parent'), parent);\n    return new PDFPageTree(dict, context);\n  };\n  PDFPageTree.fromMapWithContext = function (map, context) {\n    return new PDFPageTree(map, context);\n  };\n  return PDFPageTree;\n}(PDFDict);\nexport default PDFPageTree;","map":{"version":3,"names":["__extends","PDFArray","PDFDict","PDFName","PDFNumber","PDFPageLeaf","InvalidTargetIndexError","CorruptPageTreeError","PDFPageTree","_super","apply","arguments","prototype","Parent","lookup","of","Kids","Count","pushTreeNode","treeRef","push","pushLeafNode","leafRef","insertLeafKid","size","insertLeafNode","targetIndex","asNumber","leafsRemainingUntilTarget","idx","len","undefined","kidRef","get","kid","context","removeLeafNode","prune","remove","removeKid","ascend","visitor","traverse","kidIdx","node","newCount","set","insert","withContext","parent","dict","Map","obj","fromMapWithContext","map"],"sources":["E:/PROA/frontPROA/node_modules/pdf-lib/es/core/structures/PDFPageTree.js"],"sourcesContent":["import { __extends } from \"tslib\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFPageLeaf from \"./PDFPageLeaf\";\nimport { InvalidTargetIndexError, CorruptPageTreeError } from \"../errors\";\nvar PDFPageTree = /** @class */ (function (_super) {\n    __extends(PDFPageTree, _super);\n    function PDFPageTree() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PDFPageTree.prototype.Parent = function () {\n        return this.lookup(PDFName.of('Parent'));\n    };\n    PDFPageTree.prototype.Kids = function () {\n        return this.lookup(PDFName.of('Kids'), PDFArray);\n    };\n    PDFPageTree.prototype.Count = function () {\n        return this.lookup(PDFName.of('Count'), PDFNumber);\n    };\n    PDFPageTree.prototype.pushTreeNode = function (treeRef) {\n        var Kids = this.Kids();\n        Kids.push(treeRef);\n    };\n    PDFPageTree.prototype.pushLeafNode = function (leafRef) {\n        var Kids = this.Kids();\n        this.insertLeafKid(Kids.size(), leafRef);\n    };\n    /**\n     * Inserts the given ref as a leaf node of this page tree at the specified\n     * index (zero-based). Also increments the `Count` of each page tree in the\n     * hierarchy to accomodate the new page.\n     *\n     * Returns the ref of the PDFPageTree node into which `leafRef` was inserted,\n     * or `undefined` if it was inserted into the root node (the PDFPageTree upon\n     * which the method was first called).\n     */\n    PDFPageTree.prototype.insertLeafNode = function (leafRef, targetIndex) {\n        var Kids = this.Kids();\n        var Count = this.Count().asNumber();\n        if (targetIndex > Count) {\n            throw new InvalidTargetIndexError(targetIndex, Count);\n        }\n        var leafsRemainingUntilTarget = targetIndex;\n        for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n            if (leafsRemainingUntilTarget === 0) {\n                // Insert page and return\n                this.insertLeafKid(idx, leafRef);\n                return undefined;\n            }\n            var kidRef = Kids.get(idx);\n            var kid = this.context.lookup(kidRef);\n            if (kid instanceof PDFPageTree) {\n                if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\n                    // Dig in\n                    return (kid.insertLeafNode(leafRef, leafsRemainingUntilTarget) || kidRef);\n                }\n                else {\n                    // Move on\n                    leafsRemainingUntilTarget -= kid.Count().asNumber();\n                }\n            }\n            if (kid instanceof PDFPageLeaf) {\n                // Move on\n                leafsRemainingUntilTarget -= 1;\n            }\n        }\n        if (leafsRemainingUntilTarget === 0) {\n            // Insert page at the end and return\n            this.insertLeafKid(Kids.size(), leafRef);\n            return undefined;\n        }\n        // Should never get here if `targetIndex` is valid\n        throw new CorruptPageTreeError(targetIndex, 'insertLeafNode');\n    };\n    /**\n     * Removes the leaf node at the specified index (zero-based) from this page\n     * tree. Also decrements the `Count` of each page tree in the hierarchy to\n     * account for the removed page.\n     *\n     * If `prune` is true, then intermediate tree nodes will be removed from the\n     * tree if they contain 0 children after the leaf node is removed.\n     */\n    PDFPageTree.prototype.removeLeafNode = function (targetIndex, prune) {\n        if (prune === void 0) { prune = true; }\n        var Kids = this.Kids();\n        var Count = this.Count().asNumber();\n        if (targetIndex >= Count) {\n            throw new InvalidTargetIndexError(targetIndex, Count);\n        }\n        var leafsRemainingUntilTarget = targetIndex;\n        for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n            var kidRef = Kids.get(idx);\n            var kid = this.context.lookup(kidRef);\n            if (kid instanceof PDFPageTree) {\n                if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\n                    // Dig in\n                    kid.removeLeafNode(leafsRemainingUntilTarget, prune);\n                    if (prune && kid.Kids().size() === 0)\n                        Kids.remove(idx);\n                    return;\n                }\n                else {\n                    // Move on\n                    leafsRemainingUntilTarget -= kid.Count().asNumber();\n                }\n            }\n            if (kid instanceof PDFPageLeaf) {\n                if (leafsRemainingUntilTarget === 0) {\n                    // Remove page and return\n                    this.removeKid(idx);\n                    return;\n                }\n                else {\n                    // Move on\n                    leafsRemainingUntilTarget -= 1;\n                }\n            }\n        }\n        // Should never get here if `targetIndex` is valid\n        throw new CorruptPageTreeError(targetIndex, 'removeLeafNode');\n    };\n    PDFPageTree.prototype.ascend = function (visitor) {\n        visitor(this);\n        var Parent = this.Parent();\n        if (Parent)\n            Parent.ascend(visitor);\n    };\n    /** Performs a Post-Order traversal of this page tree */\n    PDFPageTree.prototype.traverse = function (visitor) {\n        var Kids = this.Kids();\n        for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n            var kidRef = Kids.get(idx);\n            var kid = this.context.lookup(kidRef);\n            if (kid instanceof PDFPageTree)\n                kid.traverse(visitor);\n            visitor(kid, kidRef);\n        }\n    };\n    PDFPageTree.prototype.insertLeafKid = function (kidIdx, leafRef) {\n        var Kids = this.Kids();\n        this.ascend(function (node) {\n            var newCount = node.Count().asNumber() + 1;\n            node.set(PDFName.of('Count'), PDFNumber.of(newCount));\n        });\n        Kids.insert(kidIdx, leafRef);\n    };\n    PDFPageTree.prototype.removeKid = function (kidIdx) {\n        var Kids = this.Kids();\n        var kid = Kids.lookup(kidIdx);\n        if (kid instanceof PDFPageLeaf) {\n            this.ascend(function (node) {\n                var newCount = node.Count().asNumber() - 1;\n                node.set(PDFName.of('Count'), PDFNumber.of(newCount));\n            });\n        }\n        Kids.remove(kidIdx);\n    };\n    PDFPageTree.withContext = function (context, parent) {\n        var dict = new Map();\n        dict.set(PDFName.of('Type'), PDFName.of('Pages'));\n        dict.set(PDFName.of('Kids'), context.obj([]));\n        dict.set(PDFName.of('Count'), context.obj(0));\n        if (parent)\n            dict.set(PDFName.of('Parent'), parent);\n        return new PDFPageTree(dict, context);\n    };\n    PDFPageTree.fromMapWithContext = function (map, context) {\n        return new PDFPageTree(map, context);\n    };\n    return PDFPageTree;\n}(PDFDict));\nexport default PDFPageTree;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}