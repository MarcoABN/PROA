{"ast":null,"code":"import { __extends } from \"tslib\";\nimport PDFObject from \"./PDFObject\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { copyStringIntoBuffer, padStart, utf16Decode, pdfDocEncodingDecode, toCharCode, parseDate, hasUtf16BOM } from \"../../utils\";\nimport { InvalidPDFDateStringError } from \"../errors\";\nvar PDFString = /** @class */function (_super) {\n  __extends(PDFString, _super);\n  function PDFString(value) {\n    var _this = _super.call(this) || this;\n    _this.value = value;\n    return _this;\n  }\n  PDFString.prototype.asBytes = function () {\n    var bytes = [];\n    var octal = '';\n    var escaped = false;\n    var pushByte = function (byte) {\n      if (byte !== undefined) bytes.push(byte);\n      escaped = false;\n    };\n    for (var idx = 0, len = this.value.length; idx < len; idx++) {\n      var char = this.value[idx];\n      var byte = toCharCode(char);\n      var nextChar = this.value[idx + 1];\n      if (!escaped) {\n        if (byte === CharCodes.BackSlash) escaped = true;else pushByte(byte);\n      } else {\n        if (byte === CharCodes.Newline) pushByte();else if (byte === CharCodes.CarriageReturn) pushByte();else if (byte === CharCodes.n) pushByte(CharCodes.Newline);else if (byte === CharCodes.r) pushByte(CharCodes.CarriageReturn);else if (byte === CharCodes.t) pushByte(CharCodes.Tab);else if (byte === CharCodes.b) pushByte(CharCodes.Backspace);else if (byte === CharCodes.f) pushByte(CharCodes.FormFeed);else if (byte === CharCodes.LeftParen) pushByte(CharCodes.LeftParen);else if (byte === CharCodes.RightParen) pushByte(CharCodes.RightParen);else if (byte === CharCodes.Backspace) pushByte(CharCodes.BackSlash);else if (byte >= CharCodes.Zero && byte <= CharCodes.Seven) {\n          octal += char;\n          if (octal.length === 3 || !(nextChar >= '0' && nextChar <= '7')) {\n            pushByte(parseInt(octal, 8));\n            octal = '';\n          }\n        } else {\n          pushByte(byte);\n        }\n      }\n    }\n    return new Uint8Array(bytes);\n  };\n  PDFString.prototype.decodeText = function () {\n    var bytes = this.asBytes();\n    if (hasUtf16BOM(bytes)) return utf16Decode(bytes);\n    return pdfDocEncodingDecode(bytes);\n  };\n  PDFString.prototype.decodeDate = function () {\n    var text = this.decodeText();\n    var date = parseDate(text);\n    if (!date) throw new InvalidPDFDateStringError(text);\n    return date;\n  };\n  PDFString.prototype.asString = function () {\n    return this.value;\n  };\n  PDFString.prototype.clone = function () {\n    return PDFString.of(this.value);\n  };\n  PDFString.prototype.toString = function () {\n    return \"(\" + this.value + \")\";\n  };\n  PDFString.prototype.sizeInBytes = function () {\n    return this.value.length + 2;\n  };\n  PDFString.prototype.copyBytesInto = function (buffer, offset) {\n    buffer[offset++] = CharCodes.LeftParen;\n    offset += copyStringIntoBuffer(this.value, buffer, offset);\n    buffer[offset++] = CharCodes.RightParen;\n    return this.value.length + 2;\n  };\n  // The PDF spec allows newlines and parens to appear directly within a literal\n  // string. These character _may_ be escaped. But they do not _have_ to be. So\n  // for simplicity, we will not bother escaping them.\n  PDFString.of = function (value) {\n    return new PDFString(value);\n  };\n  PDFString.fromDate = function (date) {\n    var year = padStart(String(date.getUTCFullYear()), 4, '0');\n    var month = padStart(String(date.getUTCMonth() + 1), 2, '0');\n    var day = padStart(String(date.getUTCDate()), 2, '0');\n    var hours = padStart(String(date.getUTCHours()), 2, '0');\n    var mins = padStart(String(date.getUTCMinutes()), 2, '0');\n    var secs = padStart(String(date.getUTCSeconds()), 2, '0');\n    return new PDFString(\"D:\" + year + month + day + hours + mins + secs + \"Z\");\n  };\n  return PDFString;\n}(PDFObject);\nexport default PDFString;\n//# sourceMappingURL=PDFString.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}