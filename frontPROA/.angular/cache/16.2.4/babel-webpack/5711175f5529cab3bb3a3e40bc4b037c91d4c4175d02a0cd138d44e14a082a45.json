{"ast":null,"code":"export var toCharCode = function (character) {\n  return character.charCodeAt(0);\n};\nexport var toCodePoint = function (character) {\n  return character.codePointAt(0);\n};\nexport var toHexStringOfMinLength = function (num, minLength) {\n  return padStart(num.toString(16), minLength, '0').toUpperCase();\n};\nexport var toHexString = function (num) {\n  return toHexStringOfMinLength(num, 2);\n};\nexport var charFromCode = function (code) {\n  return String.fromCharCode(code);\n};\nexport var charFromHexCode = function (hex) {\n  return charFromCode(parseInt(hex, 16));\n};\nexport var padStart = function (value, length, padChar) {\n  var padding = '';\n  for (var idx = 0, len = length - value.length; idx < len; idx++) {\n    padding += padChar;\n  }\n  return padding + value;\n};\nexport var copyStringIntoBuffer = function (str, buffer, offset) {\n  var length = str.length;\n  for (var idx = 0; idx < length; idx++) {\n    buffer[offset++] = str.charCodeAt(idx);\n  }\n  return length;\n};\nexport var addRandomSuffix = function (prefix, suffixLength) {\n  if (suffixLength === void 0) {\n    suffixLength = 4;\n  }\n  return prefix + \"-\" + Math.floor(Math.random() * Math.pow(10, suffixLength));\n};\nexport var escapeRegExp = function (str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n};\nexport var cleanText = function (text) {\n  return text.replace(/\\t|\\u0085|\\u2028|\\u2029/g, '    ').replace(/[\\b\\v]/g, '');\n};\nexport var escapedNewlineChars = ['\\\\n', '\\\\f', '\\\\r', '\\\\u000B'];\nexport var newlineChars = ['\\n', '\\f', '\\r', '\\u000B'];\nexport var isNewlineChar = function (text) {\n  return /^[\\n\\f\\r\\u000B]$/.test(text);\n};\nexport var lineSplit = function (text) {\n  return text.split(/[\\n\\f\\r\\u000B]/);\n};\nexport var mergeLines = function (text) {\n  return text.replace(/[\\n\\f\\r\\u000B]/g, ' ');\n};\n// JavaScript's String.charAt() method doesn work on strings containing UTF-16\n// characters (with high and low surrogate pairs), such as ðŸ’© (poo emoji). This\n// `charAtIndex()` function does.\n//\n// Credit: https://github.com/mathiasbynens/String.prototype.at/blob/master/at.js#L14-L48\nexport var charAtIndex = function (text, index) {\n  // Get the first code unit and code unit value\n  var cuFirst = text.charCodeAt(index);\n  var cuSecond;\n  var nextIndex = index + 1;\n  var length = 1;\n  if (\n  // Check if it's the start of a surrogate pair.\n  cuFirst >= 0xd800 && cuFirst <= 0xdbff &&\n  // high surrogate\n  text.length > nextIndex // there is a next code unit\n  ) {\n    cuSecond = text.charCodeAt(nextIndex);\n    if (cuSecond >= 0xdc00 && cuSecond <= 0xdfff) length = 2; // low surrogate\n  }\n\n  return [text.slice(index, index + length), length];\n};\nexport var charSplit = function (text) {\n  var chars = [];\n  for (var idx = 0, len = text.length; idx < len;) {\n    var _a = charAtIndex(text, idx),\n      c = _a[0],\n      cLen = _a[1];\n    chars.push(c);\n    idx += cLen;\n  }\n  return chars;\n};\nvar buildWordBreakRegex = function (wordBreaks) {\n  var newlineCharUnion = escapedNewlineChars.join('|');\n  var escapedRules = ['$'];\n  for (var idx = 0, len = wordBreaks.length; idx < len; idx++) {\n    var wordBreak = wordBreaks[idx];\n    if (isNewlineChar(wordBreak)) {\n      throw new TypeError(\"`wordBreak` must not include \" + newlineCharUnion);\n    }\n    escapedRules.push(wordBreak === '' ? '.' : escapeRegExp(wordBreak));\n  }\n  var breakRules = escapedRules.join('|');\n  return new RegExp(\"(\" + newlineCharUnion + \")|((.*?)(\" + breakRules + \"))\", 'gm');\n};\nexport var breakTextIntoLines = function (text, wordBreaks, maxWidth, computeWidthOfText) {\n  var regex = buildWordBreakRegex(wordBreaks);\n  var words = cleanText(text).match(regex);\n  var currLine = '';\n  var currWidth = 0;\n  var lines = [];\n  var pushCurrLine = function () {\n    if (currLine !== '') lines.push(currLine);\n    currLine = '';\n    currWidth = 0;\n  };\n  for (var idx = 0, len = words.length; idx < len; idx++) {\n    var word = words[idx];\n    if (isNewlineChar(word)) {\n      pushCurrLine();\n    } else {\n      var width = computeWidthOfText(word);\n      if (currWidth + width > maxWidth) pushCurrLine();\n      currLine += word;\n      currWidth += width;\n    }\n  }\n  pushCurrLine();\n  return lines;\n};\n// See section \"7.9.4 Dates\" of the PDF specification\nvar dateRegex = /^D:(\\d\\d\\d\\d)(\\d\\d)?(\\d\\d)?(\\d\\d)?(\\d\\d)?(\\d\\d)?([+\\-Z])?(\\d\\d)?'?(\\d\\d)?'?$/;\nexport var parseDate = function (dateStr) {\n  var match = dateStr.match(dateRegex);\n  if (!match) return undefined;\n  var year = match[1],\n    _a = match[2],\n    month = _a === void 0 ? '01' : _a,\n    _b = match[3],\n    day = _b === void 0 ? '01' : _b,\n    _c = match[4],\n    hours = _c === void 0 ? '00' : _c,\n    _d = match[5],\n    mins = _d === void 0 ? '00' : _d,\n    _e = match[6],\n    secs = _e === void 0 ? '00' : _e,\n    _f = match[7],\n    offsetSign = _f === void 0 ? 'Z' : _f,\n    _g = match[8],\n    offsetHours = _g === void 0 ? '00' : _g,\n    _h = match[9],\n    offsetMins = _h === void 0 ? '00' : _h;\n  // http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15\n  var tzOffset = offsetSign === 'Z' ? 'Z' : \"\" + offsetSign + offsetHours + \":\" + offsetMins;\n  var date = new Date(year + \"-\" + month + \"-\" + day + \"T\" + hours + \":\" + mins + \":\" + secs + tzOffset);\n  return date;\n};\nexport var findLastMatch = function (value, regex) {\n  var _a;\n  var position = 0;\n  var lastMatch;\n  while (position < value.length) {\n    var match = value.substring(position).match(regex);\n    if (!match) return {\n      match: lastMatch,\n      pos: position\n    };\n    lastMatch = match;\n    position += ((_a = match.index) !== null && _a !== void 0 ? _a : 0) + match[0].length;\n  }\n  return {\n    match: lastMatch,\n    pos: position\n  };\n};","map":{"version":3,"names":["toCharCode","character","charCodeAt","toCodePoint","codePointAt","toHexStringOfMinLength","num","minLength","padStart","toString","toUpperCase","toHexString","charFromCode","code","String","fromCharCode","charFromHexCode","hex","parseInt","value","length","padChar","padding","idx","len","copyStringIntoBuffer","str","buffer","offset","addRandomSuffix","prefix","suffixLength","Math","floor","random","pow","escapeRegExp","replace","cleanText","text","escapedNewlineChars","newlineChars","isNewlineChar","test","lineSplit","split","mergeLines","charAtIndex","index","cuFirst","cuSecond","nextIndex","slice","charSplit","chars","_a","c","cLen","push","buildWordBreakRegex","wordBreaks","newlineCharUnion","join","escapedRules","wordBreak","TypeError","breakRules","RegExp","breakTextIntoLines","maxWidth","computeWidthOfText","regex","words","match","currLine","currWidth","lines","pushCurrLine","word","width","dateRegex","parseDate","dateStr","undefined","year","month","_b","day","_c","hours","_d","mins","_e","secs","_f","offsetSign","_g","offsetHours","_h","offsetMins","tzOffset","date","Date","findLastMatch","position","lastMatch","substring","pos"],"sources":["E:/PROA/frontPROA/node_modules/pdf-lib/es/utils/strings.js"],"sourcesContent":["export var toCharCode = function (character) { return character.charCodeAt(0); };\nexport var toCodePoint = function (character) { return character.codePointAt(0); };\nexport var toHexStringOfMinLength = function (num, minLength) {\n    return padStart(num.toString(16), minLength, '0').toUpperCase();\n};\nexport var toHexString = function (num) { return toHexStringOfMinLength(num, 2); };\nexport var charFromCode = function (code) { return String.fromCharCode(code); };\nexport var charFromHexCode = function (hex) { return charFromCode(parseInt(hex, 16)); };\nexport var padStart = function (value, length, padChar) {\n    var padding = '';\n    for (var idx = 0, len = length - value.length; idx < len; idx++) {\n        padding += padChar;\n    }\n    return padding + value;\n};\nexport var copyStringIntoBuffer = function (str, buffer, offset) {\n    var length = str.length;\n    for (var idx = 0; idx < length; idx++) {\n        buffer[offset++] = str.charCodeAt(idx);\n    }\n    return length;\n};\nexport var addRandomSuffix = function (prefix, suffixLength) {\n    if (suffixLength === void 0) { suffixLength = 4; }\n    return prefix + \"-\" + Math.floor(Math.random() * Math.pow(10, suffixLength));\n};\nexport var escapeRegExp = function (str) {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n};\nexport var cleanText = function (text) {\n    return text.replace(/\\t|\\u0085|\\u2028|\\u2029/g, '    ').replace(/[\\b\\v]/g, '');\n};\nexport var escapedNewlineChars = ['\\\\n', '\\\\f', '\\\\r', '\\\\u000B'];\nexport var newlineChars = ['\\n', '\\f', '\\r', '\\u000B'];\nexport var isNewlineChar = function (text) { return /^[\\n\\f\\r\\u000B]$/.test(text); };\nexport var lineSplit = function (text) { return text.split(/[\\n\\f\\r\\u000B]/); };\nexport var mergeLines = function (text) {\n    return text.replace(/[\\n\\f\\r\\u000B]/g, ' ');\n};\n// JavaScript's String.charAt() method doesn work on strings containing UTF-16\n// characters (with high and low surrogate pairs), such as ðŸ’© (poo emoji). This\n// `charAtIndex()` function does.\n//\n// Credit: https://github.com/mathiasbynens/String.prototype.at/blob/master/at.js#L14-L48\nexport var charAtIndex = function (text, index) {\n    // Get the first code unit and code unit value\n    var cuFirst = text.charCodeAt(index);\n    var cuSecond;\n    var nextIndex = index + 1;\n    var length = 1;\n    if (\n    // Check if it's the start of a surrogate pair.\n    cuFirst >= 0xd800 &&\n        cuFirst <= 0xdbff && // high surrogate\n        text.length > nextIndex // there is a next code unit\n    ) {\n        cuSecond = text.charCodeAt(nextIndex);\n        if (cuSecond >= 0xdc00 && cuSecond <= 0xdfff)\n            length = 2; // low surrogate\n    }\n    return [text.slice(index, index + length), length];\n};\nexport var charSplit = function (text) {\n    var chars = [];\n    for (var idx = 0, len = text.length; idx < len;) {\n        var _a = charAtIndex(text, idx), c = _a[0], cLen = _a[1];\n        chars.push(c);\n        idx += cLen;\n    }\n    return chars;\n};\nvar buildWordBreakRegex = function (wordBreaks) {\n    var newlineCharUnion = escapedNewlineChars.join('|');\n    var escapedRules = ['$'];\n    for (var idx = 0, len = wordBreaks.length; idx < len; idx++) {\n        var wordBreak = wordBreaks[idx];\n        if (isNewlineChar(wordBreak)) {\n            throw new TypeError(\"`wordBreak` must not include \" + newlineCharUnion);\n        }\n        escapedRules.push(wordBreak === '' ? '.' : escapeRegExp(wordBreak));\n    }\n    var breakRules = escapedRules.join('|');\n    return new RegExp(\"(\" + newlineCharUnion + \")|((.*?)(\" + breakRules + \"))\", 'gm');\n};\nexport var breakTextIntoLines = function (text, wordBreaks, maxWidth, computeWidthOfText) {\n    var regex = buildWordBreakRegex(wordBreaks);\n    var words = cleanText(text).match(regex);\n    var currLine = '';\n    var currWidth = 0;\n    var lines = [];\n    var pushCurrLine = function () {\n        if (currLine !== '')\n            lines.push(currLine);\n        currLine = '';\n        currWidth = 0;\n    };\n    for (var idx = 0, len = words.length; idx < len; idx++) {\n        var word = words[idx];\n        if (isNewlineChar(word)) {\n            pushCurrLine();\n        }\n        else {\n            var width = computeWidthOfText(word);\n            if (currWidth + width > maxWidth)\n                pushCurrLine();\n            currLine += word;\n            currWidth += width;\n        }\n    }\n    pushCurrLine();\n    return lines;\n};\n// See section \"7.9.4 Dates\" of the PDF specification\nvar dateRegex = /^D:(\\d\\d\\d\\d)(\\d\\d)?(\\d\\d)?(\\d\\d)?(\\d\\d)?(\\d\\d)?([+\\-Z])?(\\d\\d)?'?(\\d\\d)?'?$/;\nexport var parseDate = function (dateStr) {\n    var match = dateStr.match(dateRegex);\n    if (!match)\n        return undefined;\n    var year = match[1], _a = match[2], month = _a === void 0 ? '01' : _a, _b = match[3], day = _b === void 0 ? '01' : _b, _c = match[4], hours = _c === void 0 ? '00' : _c, _d = match[5], mins = _d === void 0 ? '00' : _d, _e = match[6], secs = _e === void 0 ? '00' : _e, _f = match[7], offsetSign = _f === void 0 ? 'Z' : _f, _g = match[8], offsetHours = _g === void 0 ? '00' : _g, _h = match[9], offsetMins = _h === void 0 ? '00' : _h;\n    // http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15\n    var tzOffset = offsetSign === 'Z' ? 'Z' : \"\" + offsetSign + offsetHours + \":\" + offsetMins;\n    var date = new Date(year + \"-\" + month + \"-\" + day + \"T\" + hours + \":\" + mins + \":\" + secs + tzOffset);\n    return date;\n};\nexport var findLastMatch = function (value, regex) {\n    var _a;\n    var position = 0;\n    var lastMatch;\n    while (position < value.length) {\n        var match = value.substring(position).match(regex);\n        if (!match)\n            return { match: lastMatch, pos: position };\n        lastMatch = match;\n        position += ((_a = match.index) !== null && _a !== void 0 ? _a : 0) + match[0].length;\n    }\n    return { match: lastMatch, pos: position };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}