{"ast":null,"code":"import { NumberParsingError } from \"../errors\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { IsDigit, IsNumeric } from \"../syntax/Numeric\";\nimport { IsWhitespace } from \"../syntax/Whitespace\";\nimport { charFromCode } from \"../../utils\";\nvar Newline = CharCodes.Newline,\n  CarriageReturn = CharCodes.CarriageReturn;\n// TODO: Throw error if eof is reached before finishing object parse...\nvar BaseParser = /** @class */function () {\n  function BaseParser(bytes, capNumbers) {\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n    this.bytes = bytes;\n    this.capNumbers = capNumbers;\n  }\n  BaseParser.prototype.parseRawInt = function () {\n    var value = '';\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (!IsDigit[byte]) break;\n      value += charFromCode(this.bytes.next());\n    }\n    var numberValue = Number(value);\n    if (!value || !isFinite(numberValue)) {\n      throw new NumberParsingError(this.bytes.position(), value);\n    }\n    return numberValue;\n  };\n  // TODO: Maybe handle exponential format?\n  // TODO: Compare performance of string concatenation to charFromCode(...bytes)\n  BaseParser.prototype.parseRawNumber = function () {\n    var value = '';\n    // Parse integer-part, the leading (+ | - | . | 0-9)\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (!IsNumeric[byte]) break;\n      value += charFromCode(this.bytes.next());\n      if (byte === CharCodes.Period) break;\n    }\n    // Parse decimal-part, the trailing (0-9)\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (!IsDigit[byte]) break;\n      value += charFromCode(this.bytes.next());\n    }\n    var numberValue = Number(value);\n    if (!value || !isFinite(numberValue)) {\n      throw new NumberParsingError(this.bytes.position(), value);\n    }\n    if (numberValue > Number.MAX_SAFE_INTEGER) {\n      if (this.capNumbers) {\n        var msg = \"Parsed number that is too large for some PDF readers: \" + value + \", using Number.MAX_SAFE_INTEGER instead.\";\n        console.warn(msg);\n        return Number.MAX_SAFE_INTEGER;\n      } else {\n        var msg = \"Parsed number that is too large for some PDF readers: \" + value + \", not capping.\";\n        console.warn(msg);\n      }\n    }\n    return numberValue;\n  };\n  BaseParser.prototype.skipWhitespace = function () {\n    while (!this.bytes.done() && IsWhitespace[this.bytes.peek()]) {\n      this.bytes.next();\n    }\n  };\n  BaseParser.prototype.skipLine = function () {\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (byte === Newline || byte === CarriageReturn) return;\n      this.bytes.next();\n    }\n  };\n  BaseParser.prototype.skipComment = function () {\n    if (this.bytes.peek() !== CharCodes.Percent) return false;\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (byte === Newline || byte === CarriageReturn) return true;\n      this.bytes.next();\n    }\n    return true;\n  };\n  BaseParser.prototype.skipWhitespaceAndComments = function () {\n    this.skipWhitespace();\n    while (this.skipComment()) this.skipWhitespace();\n  };\n  BaseParser.prototype.matchKeyword = function (keyword) {\n    var initialOffset = this.bytes.offset();\n    for (var idx = 0, len = keyword.length; idx < len; idx++) {\n      if (this.bytes.done() || this.bytes.next() !== keyword[idx]) {\n        this.bytes.moveTo(initialOffset);\n        return false;\n      }\n    }\n    return true;\n  };\n  return BaseParser;\n}();\nexport default BaseParser;","map":{"version":3,"names":["NumberParsingError","CharCodes","IsDigit","IsNumeric","IsWhitespace","charFromCode","Newline","CarriageReturn","BaseParser","bytes","capNumbers","prototype","parseRawInt","value","done","byte","peek","next","numberValue","Number","isFinite","position","parseRawNumber","Period","MAX_SAFE_INTEGER","msg","console","warn","skipWhitespace","skipLine","skipComment","Percent","skipWhitespaceAndComments","matchKeyword","keyword","initialOffset","offset","idx","len","length","moveTo"],"sources":["E:/PROA/frontPROA/node_modules/pdf-lib/es/core/parser/BaseParser.js"],"sourcesContent":["import { NumberParsingError } from \"../errors\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { IsDigit, IsNumeric } from \"../syntax/Numeric\";\nimport { IsWhitespace } from \"../syntax/Whitespace\";\nimport { charFromCode } from \"../../utils\";\nvar Newline = CharCodes.Newline, CarriageReturn = CharCodes.CarriageReturn;\n// TODO: Throw error if eof is reached before finishing object parse...\nvar BaseParser = /** @class */ (function () {\n    function BaseParser(bytes, capNumbers) {\n        if (capNumbers === void 0) { capNumbers = false; }\n        this.bytes = bytes;\n        this.capNumbers = capNumbers;\n    }\n    BaseParser.prototype.parseRawInt = function () {\n        var value = '';\n        while (!this.bytes.done()) {\n            var byte = this.bytes.peek();\n            if (!IsDigit[byte])\n                break;\n            value += charFromCode(this.bytes.next());\n        }\n        var numberValue = Number(value);\n        if (!value || !isFinite(numberValue)) {\n            throw new NumberParsingError(this.bytes.position(), value);\n        }\n        return numberValue;\n    };\n    // TODO: Maybe handle exponential format?\n    // TODO: Compare performance of string concatenation to charFromCode(...bytes)\n    BaseParser.prototype.parseRawNumber = function () {\n        var value = '';\n        // Parse integer-part, the leading (+ | - | . | 0-9)\n        while (!this.bytes.done()) {\n            var byte = this.bytes.peek();\n            if (!IsNumeric[byte])\n                break;\n            value += charFromCode(this.bytes.next());\n            if (byte === CharCodes.Period)\n                break;\n        }\n        // Parse decimal-part, the trailing (0-9)\n        while (!this.bytes.done()) {\n            var byte = this.bytes.peek();\n            if (!IsDigit[byte])\n                break;\n            value += charFromCode(this.bytes.next());\n        }\n        var numberValue = Number(value);\n        if (!value || !isFinite(numberValue)) {\n            throw new NumberParsingError(this.bytes.position(), value);\n        }\n        if (numberValue > Number.MAX_SAFE_INTEGER) {\n            if (this.capNumbers) {\n                var msg = \"Parsed number that is too large for some PDF readers: \" + value + \", using Number.MAX_SAFE_INTEGER instead.\";\n                console.warn(msg);\n                return Number.MAX_SAFE_INTEGER;\n            }\n            else {\n                var msg = \"Parsed number that is too large for some PDF readers: \" + value + \", not capping.\";\n                console.warn(msg);\n            }\n        }\n        return numberValue;\n    };\n    BaseParser.prototype.skipWhitespace = function () {\n        while (!this.bytes.done() && IsWhitespace[this.bytes.peek()]) {\n            this.bytes.next();\n        }\n    };\n    BaseParser.prototype.skipLine = function () {\n        while (!this.bytes.done()) {\n            var byte = this.bytes.peek();\n            if (byte === Newline || byte === CarriageReturn)\n                return;\n            this.bytes.next();\n        }\n    };\n    BaseParser.prototype.skipComment = function () {\n        if (this.bytes.peek() !== CharCodes.Percent)\n            return false;\n        while (!this.bytes.done()) {\n            var byte = this.bytes.peek();\n            if (byte === Newline || byte === CarriageReturn)\n                return true;\n            this.bytes.next();\n        }\n        return true;\n    };\n    BaseParser.prototype.skipWhitespaceAndComments = function () {\n        this.skipWhitespace();\n        while (this.skipComment())\n            this.skipWhitespace();\n    };\n    BaseParser.prototype.matchKeyword = function (keyword) {\n        var initialOffset = this.bytes.offset();\n        for (var idx = 0, len = keyword.length; idx < len; idx++) {\n            if (this.bytes.done() || this.bytes.next() !== keyword[idx]) {\n                this.bytes.moveTo(initialOffset);\n                return false;\n            }\n        }\n        return true;\n    };\n    return BaseParser;\n}());\nexport default BaseParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}