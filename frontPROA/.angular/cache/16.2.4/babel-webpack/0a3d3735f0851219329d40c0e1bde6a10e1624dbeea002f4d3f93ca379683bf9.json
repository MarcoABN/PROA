{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { PDFObjectParsingError, PDFStreamParsingError, UnbalancedParenthesisError } from \"../errors\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFBool from \"../objects/PDFBool\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFHexString from \"../objects/PDFHexString\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNull from \"../objects/PDFNull\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFRawStream from \"../objects/PDFRawStream\";\nimport PDFRef from \"../objects/PDFRef\";\nimport PDFString from \"../objects/PDFString\";\nimport BaseParser from \"./BaseParser\";\nimport ByteStream from \"./ByteStream\";\nimport PDFCatalog from \"../structures/PDFCatalog\";\nimport PDFPageLeaf from \"../structures/PDFPageLeaf\";\nimport PDFPageTree from \"../structures/PDFPageTree\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { IsDelimiter } from \"../syntax/Delimiters\";\nimport { Keywords } from \"../syntax/Keywords\";\nimport { IsDigit, IsNumeric } from \"../syntax/Numeric\";\nimport { IsWhitespace } from \"../syntax/Whitespace\";\nimport { charFromCode } from \"../../utils\";\n// TODO: Throw error if eof is reached before finishing object parse...\nvar PDFObjectParser = /** @class */function (_super) {\n  __extends(PDFObjectParser, _super);\n  function PDFObjectParser(byteStream, context, capNumbers) {\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n    var _this = _super.call(this, byteStream, capNumbers) || this;\n    _this.context = context;\n    return _this;\n  }\n  // TODO: Is it possible to reduce duplicate parsing for ref lookaheads?\n  PDFObjectParser.prototype.parseObject = function () {\n    this.skipWhitespaceAndComments();\n    if (this.matchKeyword(Keywords.true)) return PDFBool.True;\n    if (this.matchKeyword(Keywords.false)) return PDFBool.False;\n    if (this.matchKeyword(Keywords.null)) return PDFNull;\n    var byte = this.bytes.peek();\n    if (byte === CharCodes.LessThan && this.bytes.peekAhead(1) === CharCodes.LessThan) {\n      return this.parseDictOrStream();\n    }\n    if (byte === CharCodes.LessThan) return this.parseHexString();\n    if (byte === CharCodes.LeftParen) return this.parseString();\n    if (byte === CharCodes.ForwardSlash) return this.parseName();\n    if (byte === CharCodes.LeftSquareBracket) return this.parseArray();\n    if (IsNumeric[byte]) return this.parseNumberOrRef();\n    throw new PDFObjectParsingError(this.bytes.position(), byte);\n  };\n  PDFObjectParser.prototype.parseNumberOrRef = function () {\n    var firstNum = this.parseRawNumber();\n    this.skipWhitespaceAndComments();\n    var lookaheadStart = this.bytes.offset();\n    if (IsDigit[this.bytes.peek()]) {\n      var secondNum = this.parseRawNumber();\n      this.skipWhitespaceAndComments();\n      if (this.bytes.peek() === CharCodes.R) {\n        this.bytes.assertNext(CharCodes.R);\n        return PDFRef.of(firstNum, secondNum);\n      }\n    }\n    this.bytes.moveTo(lookaheadStart);\n    return PDFNumber.of(firstNum);\n  };\n  // TODO: Maybe update PDFHexString.of() logic to remove whitespace and validate input?\n  PDFObjectParser.prototype.parseHexString = function () {\n    var value = '';\n    this.bytes.assertNext(CharCodes.LessThan);\n    while (!this.bytes.done() && this.bytes.peek() !== CharCodes.GreaterThan) {\n      value += charFromCode(this.bytes.next());\n    }\n    this.bytes.assertNext(CharCodes.GreaterThan);\n    return PDFHexString.of(value);\n  };\n  PDFObjectParser.prototype.parseString = function () {\n    var nestingLvl = 0;\n    var isEscaped = false;\n    var value = '';\n    while (!this.bytes.done()) {\n      var byte = this.bytes.next();\n      value += charFromCode(byte);\n      // Check for unescaped parenthesis\n      if (!isEscaped) {\n        if (byte === CharCodes.LeftParen) nestingLvl += 1;\n        if (byte === CharCodes.RightParen) nestingLvl -= 1;\n      }\n      // Track whether current character is being escaped or not\n      if (byte === CharCodes.BackSlash) {\n        isEscaped = !isEscaped;\n      } else if (isEscaped) {\n        isEscaped = false;\n      }\n      // Once (if) the unescaped parenthesis balance out, return their contents\n      if (nestingLvl === 0) {\n        // Remove the outer parens so they aren't part of the contents\n        return PDFString.of(value.substring(1, value.length - 1));\n      }\n    }\n    throw new UnbalancedParenthesisError(this.bytes.position());\n  };\n  // TODO: Compare performance of string concatenation to charFromCode(...bytes)\n  // TODO: Maybe preallocate small Uint8Array if can use charFromCode?\n  PDFObjectParser.prototype.parseName = function () {\n    this.bytes.assertNext(CharCodes.ForwardSlash);\n    var name = '';\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (IsWhitespace[byte] || IsDelimiter[byte]) break;\n      name += charFromCode(byte);\n      this.bytes.next();\n    }\n    return PDFName.of(name);\n  };\n  PDFObjectParser.prototype.parseArray = function () {\n    this.bytes.assertNext(CharCodes.LeftSquareBracket);\n    this.skipWhitespaceAndComments();\n    var pdfArray = PDFArray.withContext(this.context);\n    while (this.bytes.peek() !== CharCodes.RightSquareBracket) {\n      var element = this.parseObject();\n      pdfArray.push(element);\n      this.skipWhitespaceAndComments();\n    }\n    this.bytes.assertNext(CharCodes.RightSquareBracket);\n    return pdfArray;\n  };\n  PDFObjectParser.prototype.parseDict = function () {\n    this.bytes.assertNext(CharCodes.LessThan);\n    this.bytes.assertNext(CharCodes.LessThan);\n    this.skipWhitespaceAndComments();\n    var dict = new Map();\n    while (!this.bytes.done() && this.bytes.peek() !== CharCodes.GreaterThan && this.bytes.peekAhead(1) !== CharCodes.GreaterThan) {\n      var key = this.parseName();\n      var value = this.parseObject();\n      dict.set(key, value);\n      this.skipWhitespaceAndComments();\n    }\n    this.skipWhitespaceAndComments();\n    this.bytes.assertNext(CharCodes.GreaterThan);\n    this.bytes.assertNext(CharCodes.GreaterThan);\n    var Type = dict.get(PDFName.of('Type'));\n    if (Type === PDFName.of('Catalog')) {\n      return PDFCatalog.fromMapWithContext(dict, this.context);\n    } else if (Type === PDFName.of('Pages')) {\n      return PDFPageTree.fromMapWithContext(dict, this.context);\n    } else if (Type === PDFName.of('Page')) {\n      return PDFPageLeaf.fromMapWithContext(dict, this.context);\n    } else {\n      return PDFDict.fromMapWithContext(dict, this.context);\n    }\n  };\n  PDFObjectParser.prototype.parseDictOrStream = function () {\n    var startPos = this.bytes.position();\n    var dict = this.parseDict();\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.streamEOF1) && !this.matchKeyword(Keywords.streamEOF2) && !this.matchKeyword(Keywords.streamEOF3) && !this.matchKeyword(Keywords.streamEOF4) && !this.matchKeyword(Keywords.stream)) {\n      return dict;\n    }\n    var start = this.bytes.offset();\n    var end;\n    var Length = dict.get(PDFName.of('Length'));\n    if (Length instanceof PDFNumber) {\n      end = start + Length.asNumber();\n      this.bytes.moveTo(end);\n      this.skipWhitespaceAndComments();\n      if (!this.matchKeyword(Keywords.endstream)) {\n        this.bytes.moveTo(start);\n        end = this.findEndOfStreamFallback(startPos);\n      }\n    } else {\n      end = this.findEndOfStreamFallback(startPos);\n    }\n    var contents = this.bytes.slice(start, end);\n    return PDFRawStream.of(dict, contents);\n  };\n  PDFObjectParser.prototype.findEndOfStreamFallback = function (startPos) {\n    // Move to end of stream, while handling nested streams\n    var nestingLvl = 1;\n    var end = this.bytes.offset();\n    while (!this.bytes.done()) {\n      end = this.bytes.offset();\n      if (this.matchKeyword(Keywords.stream)) {\n        nestingLvl += 1;\n      } else if (this.matchKeyword(Keywords.EOF1endstream) || this.matchKeyword(Keywords.EOF2endstream) || this.matchKeyword(Keywords.EOF3endstream) || this.matchKeyword(Keywords.endstream)) {\n        nestingLvl -= 1;\n      } else {\n        this.bytes.next();\n      }\n      if (nestingLvl === 0) break;\n    }\n    if (nestingLvl !== 0) throw new PDFStreamParsingError(startPos);\n    return end;\n  };\n  PDFObjectParser.forBytes = function (bytes, context, capNumbers) {\n    return new PDFObjectParser(ByteStream.of(bytes), context, capNumbers);\n  };\n  PDFObjectParser.forByteStream = function (byteStream, context, capNumbers) {\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n    return new PDFObjectParser(byteStream, context, capNumbers);\n  };\n  return PDFObjectParser;\n}(BaseParser);\nexport default PDFObjectParser;","map":{"version":3,"names":["__extends","PDFObjectParsingError","PDFStreamParsingError","UnbalancedParenthesisError","PDFArray","PDFBool","PDFDict","PDFHexString","PDFName","PDFNull","PDFNumber","PDFRawStream","PDFRef","PDFString","BaseParser","ByteStream","PDFCatalog","PDFPageLeaf","PDFPageTree","CharCodes","IsDelimiter","Keywords","IsDigit","IsNumeric","IsWhitespace","charFromCode","PDFObjectParser","_super","byteStream","context","capNumbers","_this","call","prototype","parseObject","skipWhitespaceAndComments","matchKeyword","true","True","false","False","null","byte","bytes","peek","LessThan","peekAhead","parseDictOrStream","parseHexString","LeftParen","parseString","ForwardSlash","parseName","LeftSquareBracket","parseArray","parseNumberOrRef","position","firstNum","parseRawNumber","lookaheadStart","offset","secondNum","R","assertNext","of","moveTo","value","done","GreaterThan","next","nestingLvl","isEscaped","RightParen","BackSlash","substring","length","name","pdfArray","withContext","RightSquareBracket","element","push","parseDict","dict","Map","key","set","Type","get","fromMapWithContext","startPos","streamEOF1","streamEOF2","streamEOF3","streamEOF4","stream","start","end","Length","asNumber","endstream","findEndOfStreamFallback","contents","slice","EOF1endstream","EOF2endstream","EOF3endstream","forBytes","forByteStream"],"sources":["E:/PROA/frontPROA/node_modules/pdf-lib/es/core/parser/PDFObjectParser.js"],"sourcesContent":["import { __extends } from \"tslib\";\nimport { PDFObjectParsingError, PDFStreamParsingError, UnbalancedParenthesisError, } from \"../errors\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFBool from \"../objects/PDFBool\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFHexString from \"../objects/PDFHexString\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNull from \"../objects/PDFNull\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFRawStream from \"../objects/PDFRawStream\";\nimport PDFRef from \"../objects/PDFRef\";\nimport PDFString from \"../objects/PDFString\";\nimport BaseParser from \"./BaseParser\";\nimport ByteStream from \"./ByteStream\";\nimport PDFCatalog from \"../structures/PDFCatalog\";\nimport PDFPageLeaf from \"../structures/PDFPageLeaf\";\nimport PDFPageTree from \"../structures/PDFPageTree\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { IsDelimiter } from \"../syntax/Delimiters\";\nimport { Keywords } from \"../syntax/Keywords\";\nimport { IsDigit, IsNumeric } from \"../syntax/Numeric\";\nimport { IsWhitespace } from \"../syntax/Whitespace\";\nimport { charFromCode } from \"../../utils\";\n// TODO: Throw error if eof is reached before finishing object parse...\nvar PDFObjectParser = /** @class */ (function (_super) {\n    __extends(PDFObjectParser, _super);\n    function PDFObjectParser(byteStream, context, capNumbers) {\n        if (capNumbers === void 0) { capNumbers = false; }\n        var _this = _super.call(this, byteStream, capNumbers) || this;\n        _this.context = context;\n        return _this;\n    }\n    // TODO: Is it possible to reduce duplicate parsing for ref lookaheads?\n    PDFObjectParser.prototype.parseObject = function () {\n        this.skipWhitespaceAndComments();\n        if (this.matchKeyword(Keywords.true))\n            return PDFBool.True;\n        if (this.matchKeyword(Keywords.false))\n            return PDFBool.False;\n        if (this.matchKeyword(Keywords.null))\n            return PDFNull;\n        var byte = this.bytes.peek();\n        if (byte === CharCodes.LessThan &&\n            this.bytes.peekAhead(1) === CharCodes.LessThan) {\n            return this.parseDictOrStream();\n        }\n        if (byte === CharCodes.LessThan)\n            return this.parseHexString();\n        if (byte === CharCodes.LeftParen)\n            return this.parseString();\n        if (byte === CharCodes.ForwardSlash)\n            return this.parseName();\n        if (byte === CharCodes.LeftSquareBracket)\n            return this.parseArray();\n        if (IsNumeric[byte])\n            return this.parseNumberOrRef();\n        throw new PDFObjectParsingError(this.bytes.position(), byte);\n    };\n    PDFObjectParser.prototype.parseNumberOrRef = function () {\n        var firstNum = this.parseRawNumber();\n        this.skipWhitespaceAndComments();\n        var lookaheadStart = this.bytes.offset();\n        if (IsDigit[this.bytes.peek()]) {\n            var secondNum = this.parseRawNumber();\n            this.skipWhitespaceAndComments();\n            if (this.bytes.peek() === CharCodes.R) {\n                this.bytes.assertNext(CharCodes.R);\n                return PDFRef.of(firstNum, secondNum);\n            }\n        }\n        this.bytes.moveTo(lookaheadStart);\n        return PDFNumber.of(firstNum);\n    };\n    // TODO: Maybe update PDFHexString.of() logic to remove whitespace and validate input?\n    PDFObjectParser.prototype.parseHexString = function () {\n        var value = '';\n        this.bytes.assertNext(CharCodes.LessThan);\n        while (!this.bytes.done() && this.bytes.peek() !== CharCodes.GreaterThan) {\n            value += charFromCode(this.bytes.next());\n        }\n        this.bytes.assertNext(CharCodes.GreaterThan);\n        return PDFHexString.of(value);\n    };\n    PDFObjectParser.prototype.parseString = function () {\n        var nestingLvl = 0;\n        var isEscaped = false;\n        var value = '';\n        while (!this.bytes.done()) {\n            var byte = this.bytes.next();\n            value += charFromCode(byte);\n            // Check for unescaped parenthesis\n            if (!isEscaped) {\n                if (byte === CharCodes.LeftParen)\n                    nestingLvl += 1;\n                if (byte === CharCodes.RightParen)\n                    nestingLvl -= 1;\n            }\n            // Track whether current character is being escaped or not\n            if (byte === CharCodes.BackSlash) {\n                isEscaped = !isEscaped;\n            }\n            else if (isEscaped) {\n                isEscaped = false;\n            }\n            // Once (if) the unescaped parenthesis balance out, return their contents\n            if (nestingLvl === 0) {\n                // Remove the outer parens so they aren't part of the contents\n                return PDFString.of(value.substring(1, value.length - 1));\n            }\n        }\n        throw new UnbalancedParenthesisError(this.bytes.position());\n    };\n    // TODO: Compare performance of string concatenation to charFromCode(...bytes)\n    // TODO: Maybe preallocate small Uint8Array if can use charFromCode?\n    PDFObjectParser.prototype.parseName = function () {\n        this.bytes.assertNext(CharCodes.ForwardSlash);\n        var name = '';\n        while (!this.bytes.done()) {\n            var byte = this.bytes.peek();\n            if (IsWhitespace[byte] || IsDelimiter[byte])\n                break;\n            name += charFromCode(byte);\n            this.bytes.next();\n        }\n        return PDFName.of(name);\n    };\n    PDFObjectParser.prototype.parseArray = function () {\n        this.bytes.assertNext(CharCodes.LeftSquareBracket);\n        this.skipWhitespaceAndComments();\n        var pdfArray = PDFArray.withContext(this.context);\n        while (this.bytes.peek() !== CharCodes.RightSquareBracket) {\n            var element = this.parseObject();\n            pdfArray.push(element);\n            this.skipWhitespaceAndComments();\n        }\n        this.bytes.assertNext(CharCodes.RightSquareBracket);\n        return pdfArray;\n    };\n    PDFObjectParser.prototype.parseDict = function () {\n        this.bytes.assertNext(CharCodes.LessThan);\n        this.bytes.assertNext(CharCodes.LessThan);\n        this.skipWhitespaceAndComments();\n        var dict = new Map();\n        while (!this.bytes.done() &&\n            this.bytes.peek() !== CharCodes.GreaterThan &&\n            this.bytes.peekAhead(1) !== CharCodes.GreaterThan) {\n            var key = this.parseName();\n            var value = this.parseObject();\n            dict.set(key, value);\n            this.skipWhitespaceAndComments();\n        }\n        this.skipWhitespaceAndComments();\n        this.bytes.assertNext(CharCodes.GreaterThan);\n        this.bytes.assertNext(CharCodes.GreaterThan);\n        var Type = dict.get(PDFName.of('Type'));\n        if (Type === PDFName.of('Catalog')) {\n            return PDFCatalog.fromMapWithContext(dict, this.context);\n        }\n        else if (Type === PDFName.of('Pages')) {\n            return PDFPageTree.fromMapWithContext(dict, this.context);\n        }\n        else if (Type === PDFName.of('Page')) {\n            return PDFPageLeaf.fromMapWithContext(dict, this.context);\n        }\n        else {\n            return PDFDict.fromMapWithContext(dict, this.context);\n        }\n    };\n    PDFObjectParser.prototype.parseDictOrStream = function () {\n        var startPos = this.bytes.position();\n        var dict = this.parseDict();\n        this.skipWhitespaceAndComments();\n        if (!this.matchKeyword(Keywords.streamEOF1) &&\n            !this.matchKeyword(Keywords.streamEOF2) &&\n            !this.matchKeyword(Keywords.streamEOF3) &&\n            !this.matchKeyword(Keywords.streamEOF4) &&\n            !this.matchKeyword(Keywords.stream)) {\n            return dict;\n        }\n        var start = this.bytes.offset();\n        var end;\n        var Length = dict.get(PDFName.of('Length'));\n        if (Length instanceof PDFNumber) {\n            end = start + Length.asNumber();\n            this.bytes.moveTo(end);\n            this.skipWhitespaceAndComments();\n            if (!this.matchKeyword(Keywords.endstream)) {\n                this.bytes.moveTo(start);\n                end = this.findEndOfStreamFallback(startPos);\n            }\n        }\n        else {\n            end = this.findEndOfStreamFallback(startPos);\n        }\n        var contents = this.bytes.slice(start, end);\n        return PDFRawStream.of(dict, contents);\n    };\n    PDFObjectParser.prototype.findEndOfStreamFallback = function (startPos) {\n        // Move to end of stream, while handling nested streams\n        var nestingLvl = 1;\n        var end = this.bytes.offset();\n        while (!this.bytes.done()) {\n            end = this.bytes.offset();\n            if (this.matchKeyword(Keywords.stream)) {\n                nestingLvl += 1;\n            }\n            else if (this.matchKeyword(Keywords.EOF1endstream) ||\n                this.matchKeyword(Keywords.EOF2endstream) ||\n                this.matchKeyword(Keywords.EOF3endstream) ||\n                this.matchKeyword(Keywords.endstream)) {\n                nestingLvl -= 1;\n            }\n            else {\n                this.bytes.next();\n            }\n            if (nestingLvl === 0)\n                break;\n        }\n        if (nestingLvl !== 0)\n            throw new PDFStreamParsingError(startPos);\n        return end;\n    };\n    PDFObjectParser.forBytes = function (bytes, context, capNumbers) { return new PDFObjectParser(ByteStream.of(bytes), context, capNumbers); };\n    PDFObjectParser.forByteStream = function (byteStream, context, capNumbers) {\n        if (capNumbers === void 0) { capNumbers = false; }\n        return new PDFObjectParser(byteStream, context, capNumbers);\n    };\n    return PDFObjectParser;\n}(BaseParser));\nexport default PDFObjectParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}