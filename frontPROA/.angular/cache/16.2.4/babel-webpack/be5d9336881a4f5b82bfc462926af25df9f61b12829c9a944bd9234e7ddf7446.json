{"ast":null,"code":"import { __extends } from \"tslib\";\nimport PDFString from \"../objects/PDFString\";\nimport PDFHexString from \"../objects/PDFHexString\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFAcroTerminal from \"./PDFAcroTerminal\";\nimport { IndexOutOfBoundsError } from \"../errors\";\nvar PDFAcroButton = /** @class */function (_super) {\n  __extends(PDFAcroButton, _super);\n  function PDFAcroButton() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  PDFAcroButton.prototype.Opt = function () {\n    return this.dict.lookupMaybe(PDFName.of('Opt'), PDFString, PDFHexString, PDFArray);\n  };\n  PDFAcroButton.prototype.setOpt = function (opt) {\n    this.dict.set(PDFName.of('Opt'), this.dict.context.obj(opt));\n  };\n  PDFAcroButton.prototype.getExportValues = function () {\n    var opt = this.Opt();\n    if (!opt) return undefined;\n    if (opt instanceof PDFString || opt instanceof PDFHexString) {\n      return [opt];\n    }\n    var values = [];\n    for (var idx = 0, len = opt.size(); idx < len; idx++) {\n      var value = opt.lookup(idx);\n      if (value instanceof PDFString || value instanceof PDFHexString) {\n        values.push(value);\n      }\n    }\n    return values;\n  };\n  PDFAcroButton.prototype.removeExportValue = function (idx) {\n    var opt = this.Opt();\n    if (!opt) return;\n    if (opt instanceof PDFString || opt instanceof PDFHexString) {\n      if (idx !== 0) throw new IndexOutOfBoundsError(idx, 0, 0);\n      this.setOpt([]);\n    } else {\n      if (idx < 0 || idx > opt.size()) {\n        throw new IndexOutOfBoundsError(idx, 0, opt.size());\n      }\n      opt.remove(idx);\n    }\n  };\n  // Enforce use use of /Opt even if it isn't strictly necessary\n  PDFAcroButton.prototype.normalizeExportValues = function () {\n    var _a, _b, _c, _d;\n    var exportValues = (_a = this.getExportValues()) !== null && _a !== void 0 ? _a : [];\n    var Opt = [];\n    var widgets = this.getWidgets();\n    for (var idx = 0, len = widgets.length; idx < len; idx++) {\n      var widget = widgets[idx];\n      var exportVal = (_b = exportValues[idx]) !== null && _b !== void 0 ? _b : PDFHexString.fromText((_d = (_c = widget.getOnValue()) === null || _c === void 0 ? void 0 : _c.decodeText()) !== null && _d !== void 0 ? _d : '');\n      Opt.push(exportVal);\n    }\n    this.setOpt(Opt);\n  };\n  /**\n   * Reuses existing opt if one exists with the same value (assuming\n   * `useExistingIdx` is `true`). Returns index of existing (or new) opt.\n   */\n  PDFAcroButton.prototype.addOpt = function (opt, useExistingOptIdx) {\n    var _a;\n    this.normalizeExportValues();\n    var optText = opt.decodeText();\n    var existingIdx;\n    if (useExistingOptIdx) {\n      var exportValues = (_a = this.getExportValues()) !== null && _a !== void 0 ? _a : [];\n      for (var idx = 0, len = exportValues.length; idx < len; idx++) {\n        var exportVal = exportValues[idx];\n        if (exportVal.decodeText() === optText) existingIdx = idx;\n      }\n    }\n    var Opt = this.Opt();\n    Opt.push(opt);\n    return existingIdx !== null && existingIdx !== void 0 ? existingIdx : Opt.size() - 1;\n  };\n  PDFAcroButton.prototype.addWidgetWithOpt = function (widget, opt, useExistingOptIdx) {\n    var optIdx = this.addOpt(opt, useExistingOptIdx);\n    var apStateValue = PDFName.of(String(optIdx));\n    this.addWidget(widget);\n    return apStateValue;\n  };\n  return PDFAcroButton;\n}(PDFAcroTerminal);\nexport default PDFAcroButton;\n//# sourceMappingURL=PDFAcroButton.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}