{"ast":null,"code":"import { ReparseError } from \"../errors\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFRef from \"../objects/PDFRef\";\nimport ByteStream from \"./ByteStream\";\nvar PDFXRefStreamParser = /** @class */function () {\n  function PDFXRefStreamParser(rawStream) {\n    this.alreadyParsed = false;\n    this.dict = rawStream.dict;\n    this.bytes = ByteStream.fromPDFRawStream(rawStream);\n    this.context = this.dict.context;\n    var Size = this.dict.lookup(PDFName.of('Size'), PDFNumber);\n    var Index = this.dict.lookup(PDFName.of('Index'));\n    if (Index instanceof PDFArray) {\n      this.subsections = [];\n      for (var idx = 0, len = Index.size(); idx < len; idx += 2) {\n        var firstObjectNumber = Index.lookup(idx + 0, PDFNumber).asNumber();\n        var length_1 = Index.lookup(idx + 1, PDFNumber).asNumber();\n        this.subsections.push({\n          firstObjectNumber: firstObjectNumber,\n          length: length_1\n        });\n      }\n    } else {\n      this.subsections = [{\n        firstObjectNumber: 0,\n        length: Size.asNumber()\n      }];\n    }\n    var W = this.dict.lookup(PDFName.of('W'), PDFArray);\n    this.byteWidths = [-1, -1, -1];\n    for (var idx = 0, len = W.size(); idx < len; idx++) {\n      this.byteWidths[idx] = W.lookup(idx, PDFNumber).asNumber();\n    }\n  }\n  PDFXRefStreamParser.prototype.parseIntoContext = function () {\n    if (this.alreadyParsed) {\n      throw new ReparseError('PDFXRefStreamParser', 'parseIntoContext');\n    }\n    this.alreadyParsed = true;\n    this.context.trailerInfo = {\n      Root: this.dict.get(PDFName.of('Root')),\n      Encrypt: this.dict.get(PDFName.of('Encrypt')),\n      Info: this.dict.get(PDFName.of('Info')),\n      ID: this.dict.get(PDFName.of('ID'))\n    };\n    var entries = this.parseEntries();\n    // for (let idx = 0, len = entries.length; idx < len; idx++) {\n    // const entry = entries[idx];\n    // if (entry.deleted) this.context.delete(entry.ref);\n    // }\n    return entries;\n  };\n  PDFXRefStreamParser.prototype.parseEntries = function () {\n    var entries = [];\n    var _a = this.byteWidths,\n      typeFieldWidth = _a[0],\n      offsetFieldWidth = _a[1],\n      genFieldWidth = _a[2];\n    for (var subsectionIdx = 0, subsectionLen = this.subsections.length; subsectionIdx < subsectionLen; subsectionIdx++) {\n      var _b = this.subsections[subsectionIdx],\n        firstObjectNumber = _b.firstObjectNumber,\n        length_2 = _b.length;\n      for (var objIdx = 0; objIdx < length_2; objIdx++) {\n        var type = 0;\n        for (var idx = 0, len = typeFieldWidth; idx < len; idx++) {\n          type = type << 8 | this.bytes.next();\n        }\n        var offset = 0;\n        for (var idx = 0, len = offsetFieldWidth; idx < len; idx++) {\n          offset = offset << 8 | this.bytes.next();\n        }\n        var generationNumber = 0;\n        for (var idx = 0, len = genFieldWidth; idx < len; idx++) {\n          generationNumber = generationNumber << 8 | this.bytes.next();\n        }\n        // When the `type` field is absent, it defaults to 1\n        if (typeFieldWidth === 0) type = 1;\n        var objectNumber = firstObjectNumber + objIdx;\n        var entry = {\n          ref: PDFRef.of(objectNumber, generationNumber),\n          offset: offset,\n          deleted: type === 0,\n          inObjectStream: type === 2\n        };\n        entries.push(entry);\n      }\n    }\n    return entries;\n  };\n  PDFXRefStreamParser.forStream = function (rawStream) {\n    return new PDFXRefStreamParser(rawStream);\n  };\n  return PDFXRefStreamParser;\n}();\nexport default PDFXRefStreamParser;\n//# sourceMappingURL=PDFXRefStreamParser.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}