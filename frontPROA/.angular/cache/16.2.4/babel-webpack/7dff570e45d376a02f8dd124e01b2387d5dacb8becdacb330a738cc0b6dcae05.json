{"ast":null,"code":"import { decodeFromBase64DataUri } from \"./base64\";\nimport { charFromCode } from \"./strings\";\nexport var last = function (array) {\n  return array[array.length - 1];\n};\n// export const dropLast = <T>(array: T[]): T[] =>\n// array.slice(0, array.length - 1);\nexport var typedArrayFor = function (value) {\n  if (value instanceof Uint8Array) return value;\n  var length = value.length;\n  var typedArray = new Uint8Array(length);\n  for (var idx = 0; idx < length; idx++) {\n    typedArray[idx] = value.charCodeAt(idx);\n  }\n  return typedArray;\n};\nexport var mergeIntoTypedArray = function () {\n  var arrays = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    arrays[_i] = arguments[_i];\n  }\n  var arrayCount = arrays.length;\n  var typedArrays = [];\n  for (var idx = 0; idx < arrayCount; idx++) {\n    var element = arrays[idx];\n    typedArrays[idx] = element instanceof Uint8Array ? element : typedArrayFor(element);\n  }\n  var totalSize = 0;\n  for (var idx = 0; idx < arrayCount; idx++) {\n    totalSize += arrays[idx].length;\n  }\n  var merged = new Uint8Array(totalSize);\n  var offset = 0;\n  for (var arrIdx = 0; arrIdx < arrayCount; arrIdx++) {\n    var arr = typedArrays[arrIdx];\n    for (var byteIdx = 0, arrLen = arr.length; byteIdx < arrLen; byteIdx++) {\n      merged[offset++] = arr[byteIdx];\n    }\n  }\n  return merged;\n};\nexport var mergeUint8Arrays = function (arrays) {\n  var totalSize = 0;\n  for (var idx = 0, len = arrays.length; idx < len; idx++) {\n    totalSize += arrays[idx].length;\n  }\n  var mergedBuffer = new Uint8Array(totalSize);\n  var offset = 0;\n  for (var idx = 0, len = arrays.length; idx < len; idx++) {\n    var array = arrays[idx];\n    mergedBuffer.set(array, offset);\n    offset += array.length;\n  }\n  return mergedBuffer;\n};\nexport var arrayAsString = function (array) {\n  var str = '';\n  for (var idx = 0, len = array.length; idx < len; idx++) {\n    str += charFromCode(array[idx]);\n  }\n  return str;\n};\nexport var byAscendingId = function (a, b) {\n  return a.id - b.id;\n};\nexport var sortedUniq = function (array, indexer) {\n  var uniq = [];\n  for (var idx = 0, len = array.length; idx < len; idx++) {\n    var curr = array[idx];\n    var prev = array[idx - 1];\n    if (idx === 0 || indexer(curr) !== indexer(prev)) {\n      uniq.push(curr);\n    }\n  }\n  return uniq;\n};\n// Arrays and TypedArrays in JS both have .reverse() methods, which would seem\n// to negate the need for this function. However, not all runtimes support this\n// method (e.g. React Native). This function compensates for that fact.\nexport var reverseArray = function (array) {\n  var arrayLen = array.length;\n  for (var idx = 0, len = Math.floor(arrayLen / 2); idx < len; idx++) {\n    var leftIdx = idx;\n    var rightIdx = arrayLen - idx - 1;\n    var temp = array[idx];\n    array[leftIdx] = array[rightIdx];\n    array[rightIdx] = temp;\n  }\n  return array;\n};\nexport var sum = function (array) {\n  var total = 0;\n  for (var idx = 0, len = array.length; idx < len; idx++) {\n    total += array[idx];\n  }\n  return total;\n};\nexport var range = function (start, end) {\n  var arr = new Array(end - start);\n  for (var idx = 0, len = arr.length; idx < len; idx++) {\n    arr[idx] = start + idx;\n  }\n  return arr;\n};\nexport var pluckIndices = function (arr, indices) {\n  var plucked = new Array(indices.length);\n  for (var idx = 0, len = indices.length; idx < len; idx++) {\n    plucked[idx] = arr[indices[idx]];\n  }\n  return plucked;\n};\nexport var canBeConvertedToUint8Array = function (input) {\n  return input instanceof Uint8Array || input instanceof ArrayBuffer || typeof input === 'string';\n};\nexport var toUint8Array = function (input) {\n  if (typeof input === 'string') {\n    return decodeFromBase64DataUri(input);\n  } else if (input instanceof ArrayBuffer) {\n    return new Uint8Array(input);\n  } else if (input instanceof Uint8Array) {\n    return input;\n  } else {\n    throw new TypeError('`input` must be one of `string | ArrayBuffer | Uint8Array`');\n  }\n};","map":{"version":3,"names":["decodeFromBase64DataUri","charFromCode","last","array","length","typedArrayFor","value","Uint8Array","typedArray","idx","charCodeAt","mergeIntoTypedArray","arrays","_i","arguments","arrayCount","typedArrays","element","totalSize","merged","offset","arrIdx","arr","byteIdx","arrLen","mergeUint8Arrays","len","mergedBuffer","set","arrayAsString","str","byAscendingId","a","b","id","sortedUniq","indexer","uniq","curr","prev","push","reverseArray","arrayLen","Math","floor","leftIdx","rightIdx","temp","sum","total","range","start","end","Array","pluckIndices","indices","plucked","canBeConvertedToUint8Array","input","ArrayBuffer","toUint8Array","TypeError"],"sources":["E:/PROA/frontPROA/node_modules/pdf-lib/es/utils/arrays.js"],"sourcesContent":["import { decodeFromBase64DataUri } from \"./base64\";\nimport { charFromCode } from \"./strings\";\nexport var last = function (array) { return array[array.length - 1]; };\n// export const dropLast = <T>(array: T[]): T[] =>\n// array.slice(0, array.length - 1);\nexport var typedArrayFor = function (value) {\n    if (value instanceof Uint8Array)\n        return value;\n    var length = value.length;\n    var typedArray = new Uint8Array(length);\n    for (var idx = 0; idx < length; idx++) {\n        typedArray[idx] = value.charCodeAt(idx);\n    }\n    return typedArray;\n};\nexport var mergeIntoTypedArray = function () {\n    var arrays = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        arrays[_i] = arguments[_i];\n    }\n    var arrayCount = arrays.length;\n    var typedArrays = [];\n    for (var idx = 0; idx < arrayCount; idx++) {\n        var element = arrays[idx];\n        typedArrays[idx] =\n            element instanceof Uint8Array ? element : typedArrayFor(element);\n    }\n    var totalSize = 0;\n    for (var idx = 0; idx < arrayCount; idx++) {\n        totalSize += arrays[idx].length;\n    }\n    var merged = new Uint8Array(totalSize);\n    var offset = 0;\n    for (var arrIdx = 0; arrIdx < arrayCount; arrIdx++) {\n        var arr = typedArrays[arrIdx];\n        for (var byteIdx = 0, arrLen = arr.length; byteIdx < arrLen; byteIdx++) {\n            merged[offset++] = arr[byteIdx];\n        }\n    }\n    return merged;\n};\nexport var mergeUint8Arrays = function (arrays) {\n    var totalSize = 0;\n    for (var idx = 0, len = arrays.length; idx < len; idx++) {\n        totalSize += arrays[idx].length;\n    }\n    var mergedBuffer = new Uint8Array(totalSize);\n    var offset = 0;\n    for (var idx = 0, len = arrays.length; idx < len; idx++) {\n        var array = arrays[idx];\n        mergedBuffer.set(array, offset);\n        offset += array.length;\n    }\n    return mergedBuffer;\n};\nexport var arrayAsString = function (array) {\n    var str = '';\n    for (var idx = 0, len = array.length; idx < len; idx++) {\n        str += charFromCode(array[idx]);\n    }\n    return str;\n};\nexport var byAscendingId = function (a, b) { return a.id - b.id; };\nexport var sortedUniq = function (array, indexer) {\n    var uniq = [];\n    for (var idx = 0, len = array.length; idx < len; idx++) {\n        var curr = array[idx];\n        var prev = array[idx - 1];\n        if (idx === 0 || indexer(curr) !== indexer(prev)) {\n            uniq.push(curr);\n        }\n    }\n    return uniq;\n};\n// Arrays and TypedArrays in JS both have .reverse() methods, which would seem\n// to negate the need for this function. However, not all runtimes support this\n// method (e.g. React Native). This function compensates for that fact.\nexport var reverseArray = function (array) {\n    var arrayLen = array.length;\n    for (var idx = 0, len = Math.floor(arrayLen / 2); idx < len; idx++) {\n        var leftIdx = idx;\n        var rightIdx = arrayLen - idx - 1;\n        var temp = array[idx];\n        array[leftIdx] = array[rightIdx];\n        array[rightIdx] = temp;\n    }\n    return array;\n};\nexport var sum = function (array) {\n    var total = 0;\n    for (var idx = 0, len = array.length; idx < len; idx++) {\n        total += array[idx];\n    }\n    return total;\n};\nexport var range = function (start, end) {\n    var arr = new Array(end - start);\n    for (var idx = 0, len = arr.length; idx < len; idx++) {\n        arr[idx] = start + idx;\n    }\n    return arr;\n};\nexport var pluckIndices = function (arr, indices) {\n    var plucked = new Array(indices.length);\n    for (var idx = 0, len = indices.length; idx < len; idx++) {\n        plucked[idx] = arr[indices[idx]];\n    }\n    return plucked;\n};\nexport var canBeConvertedToUint8Array = function (input) {\n    return input instanceof Uint8Array ||\n        input instanceof ArrayBuffer ||\n        typeof input === 'string';\n};\nexport var toUint8Array = function (input) {\n    if (typeof input === 'string') {\n        return decodeFromBase64DataUri(input);\n    }\n    else if (input instanceof ArrayBuffer) {\n        return new Uint8Array(input);\n    }\n    else if (input instanceof Uint8Array) {\n        return input;\n    }\n    else {\n        throw new TypeError('`input` must be one of `string | ArrayBuffer | Uint8Array`');\n    }\n};\n"],"mappings":"AAAA,SAASA,uBAAuB,QAAQ,UAAU;AAClD,SAASC,YAAY,QAAQ,WAAW;AACxC,OAAO,IAAIC,IAAI,GAAG,SAAAA,CAAUC,KAAK,EAAE;EAAE,OAAOA,KAAK,CAACA,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC;AAAE,CAAC;AACtE;AACA;AACA,OAAO,IAAIC,aAAa,GAAG,SAAAA,CAAUC,KAAK,EAAE;EACxC,IAAIA,KAAK,YAAYC,UAAU,EAC3B,OAAOD,KAAK;EAChB,IAAIF,MAAM,GAAGE,KAAK,CAACF,MAAM;EACzB,IAAII,UAAU,GAAG,IAAID,UAAU,CAACH,MAAM,CAAC;EACvC,KAAK,IAAIK,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGL,MAAM,EAAEK,GAAG,EAAE,EAAE;IACnCD,UAAU,CAACC,GAAG,CAAC,GAAGH,KAAK,CAACI,UAAU,CAACD,GAAG,CAAC;EAC3C;EACA,OAAOD,UAAU;AACrB,CAAC;AACD,OAAO,IAAIG,mBAAmB,GAAG,SAAAA,CAAA,EAAY;EACzC,IAAIC,MAAM,GAAG,EAAE;EACf,KAAK,IAAIC,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGC,SAAS,CAACV,MAAM,EAAES,EAAE,EAAE,EAAE;IAC1CD,MAAM,CAACC,EAAE,CAAC,GAAGC,SAAS,CAACD,EAAE,CAAC;EAC9B;EACA,IAAIE,UAAU,GAAGH,MAAM,CAACR,MAAM;EAC9B,IAAIY,WAAW,GAAG,EAAE;EACpB,KAAK,IAAIP,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGM,UAAU,EAAEN,GAAG,EAAE,EAAE;IACvC,IAAIQ,OAAO,GAAGL,MAAM,CAACH,GAAG,CAAC;IACzBO,WAAW,CAACP,GAAG,CAAC,GACZQ,OAAO,YAAYV,UAAU,GAAGU,OAAO,GAAGZ,aAAa,CAACY,OAAO,CAAC;EACxE;EACA,IAAIC,SAAS,GAAG,CAAC;EACjB,KAAK,IAAIT,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGM,UAAU,EAAEN,GAAG,EAAE,EAAE;IACvCS,SAAS,IAAIN,MAAM,CAACH,GAAG,CAAC,CAACL,MAAM;EACnC;EACA,IAAIe,MAAM,GAAG,IAAIZ,UAAU,CAACW,SAAS,CAAC;EACtC,IAAIE,MAAM,GAAG,CAAC;EACd,KAAK,IAAIC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGN,UAAU,EAAEM,MAAM,EAAE,EAAE;IAChD,IAAIC,GAAG,GAAGN,WAAW,CAACK,MAAM,CAAC;IAC7B,KAAK,IAAIE,OAAO,GAAG,CAAC,EAAEC,MAAM,GAAGF,GAAG,CAAClB,MAAM,EAAEmB,OAAO,GAAGC,MAAM,EAAED,OAAO,EAAE,EAAE;MACpEJ,MAAM,CAACC,MAAM,EAAE,CAAC,GAAGE,GAAG,CAACC,OAAO,CAAC;IACnC;EACJ;EACA,OAAOJ,MAAM;AACjB,CAAC;AACD,OAAO,IAAIM,gBAAgB,GAAG,SAAAA,CAAUb,MAAM,EAAE;EAC5C,IAAIM,SAAS,GAAG,CAAC;EACjB,KAAK,IAAIT,GAAG,GAAG,CAAC,EAAEiB,GAAG,GAAGd,MAAM,CAACR,MAAM,EAAEK,GAAG,GAAGiB,GAAG,EAAEjB,GAAG,EAAE,EAAE;IACrDS,SAAS,IAAIN,MAAM,CAACH,GAAG,CAAC,CAACL,MAAM;EACnC;EACA,IAAIuB,YAAY,GAAG,IAAIpB,UAAU,CAACW,SAAS,CAAC;EAC5C,IAAIE,MAAM,GAAG,CAAC;EACd,KAAK,IAAIX,GAAG,GAAG,CAAC,EAAEiB,GAAG,GAAGd,MAAM,CAACR,MAAM,EAAEK,GAAG,GAAGiB,GAAG,EAAEjB,GAAG,EAAE,EAAE;IACrD,IAAIN,KAAK,GAAGS,MAAM,CAACH,GAAG,CAAC;IACvBkB,YAAY,CAACC,GAAG,CAACzB,KAAK,EAAEiB,MAAM,CAAC;IAC/BA,MAAM,IAAIjB,KAAK,CAACC,MAAM;EAC1B;EACA,OAAOuB,YAAY;AACvB,CAAC;AACD,OAAO,IAAIE,aAAa,GAAG,SAAAA,CAAU1B,KAAK,EAAE;EACxC,IAAI2B,GAAG,GAAG,EAAE;EACZ,KAAK,IAAIrB,GAAG,GAAG,CAAC,EAAEiB,GAAG,GAAGvB,KAAK,CAACC,MAAM,EAAEK,GAAG,GAAGiB,GAAG,EAAEjB,GAAG,EAAE,EAAE;IACpDqB,GAAG,IAAI7B,YAAY,CAACE,KAAK,CAACM,GAAG,CAAC,CAAC;EACnC;EACA,OAAOqB,GAAG;AACd,CAAC;AACD,OAAO,IAAIC,aAAa,GAAG,SAAAA,CAAUC,CAAC,EAAEC,CAAC,EAAE;EAAE,OAAOD,CAAC,CAACE,EAAE,GAAGD,CAAC,CAACC,EAAE;AAAE,CAAC;AAClE,OAAO,IAAIC,UAAU,GAAG,SAAAA,CAAUhC,KAAK,EAAEiC,OAAO,EAAE;EAC9C,IAAIC,IAAI,GAAG,EAAE;EACb,KAAK,IAAI5B,GAAG,GAAG,CAAC,EAAEiB,GAAG,GAAGvB,KAAK,CAACC,MAAM,EAAEK,GAAG,GAAGiB,GAAG,EAAEjB,GAAG,EAAE,EAAE;IACpD,IAAI6B,IAAI,GAAGnC,KAAK,CAACM,GAAG,CAAC;IACrB,IAAI8B,IAAI,GAAGpC,KAAK,CAACM,GAAG,GAAG,CAAC,CAAC;IACzB,IAAIA,GAAG,KAAK,CAAC,IAAI2B,OAAO,CAACE,IAAI,CAAC,KAAKF,OAAO,CAACG,IAAI,CAAC,EAAE;MAC9CF,IAAI,CAACG,IAAI,CAACF,IAAI,CAAC;IACnB;EACJ;EACA,OAAOD,IAAI;AACf,CAAC;AACD;AACA;AACA;AACA,OAAO,IAAII,YAAY,GAAG,SAAAA,CAAUtC,KAAK,EAAE;EACvC,IAAIuC,QAAQ,GAAGvC,KAAK,CAACC,MAAM;EAC3B,KAAK,IAAIK,GAAG,GAAG,CAAC,EAAEiB,GAAG,GAAGiB,IAAI,CAACC,KAAK,CAACF,QAAQ,GAAG,CAAC,CAAC,EAAEjC,GAAG,GAAGiB,GAAG,EAAEjB,GAAG,EAAE,EAAE;IAChE,IAAIoC,OAAO,GAAGpC,GAAG;IACjB,IAAIqC,QAAQ,GAAGJ,QAAQ,GAAGjC,GAAG,GAAG,CAAC;IACjC,IAAIsC,IAAI,GAAG5C,KAAK,CAACM,GAAG,CAAC;IACrBN,KAAK,CAAC0C,OAAO,CAAC,GAAG1C,KAAK,CAAC2C,QAAQ,CAAC;IAChC3C,KAAK,CAAC2C,QAAQ,CAAC,GAAGC,IAAI;EAC1B;EACA,OAAO5C,KAAK;AAChB,CAAC;AACD,OAAO,IAAI6C,GAAG,GAAG,SAAAA,CAAU7C,KAAK,EAAE;EAC9B,IAAI8C,KAAK,GAAG,CAAC;EACb,KAAK,IAAIxC,GAAG,GAAG,CAAC,EAAEiB,GAAG,GAAGvB,KAAK,CAACC,MAAM,EAAEK,GAAG,GAAGiB,GAAG,EAAEjB,GAAG,EAAE,EAAE;IACpDwC,KAAK,IAAI9C,KAAK,CAACM,GAAG,CAAC;EACvB;EACA,OAAOwC,KAAK;AAChB,CAAC;AACD,OAAO,IAAIC,KAAK,GAAG,SAAAA,CAAUC,KAAK,EAAEC,GAAG,EAAE;EACrC,IAAI9B,GAAG,GAAG,IAAI+B,KAAK,CAACD,GAAG,GAAGD,KAAK,CAAC;EAChC,KAAK,IAAI1C,GAAG,GAAG,CAAC,EAAEiB,GAAG,GAAGJ,GAAG,CAAClB,MAAM,EAAEK,GAAG,GAAGiB,GAAG,EAAEjB,GAAG,EAAE,EAAE;IAClDa,GAAG,CAACb,GAAG,CAAC,GAAG0C,KAAK,GAAG1C,GAAG;EAC1B;EACA,OAAOa,GAAG;AACd,CAAC;AACD,OAAO,IAAIgC,YAAY,GAAG,SAAAA,CAAUhC,GAAG,EAAEiC,OAAO,EAAE;EAC9C,IAAIC,OAAO,GAAG,IAAIH,KAAK,CAACE,OAAO,CAACnD,MAAM,CAAC;EACvC,KAAK,IAAIK,GAAG,GAAG,CAAC,EAAEiB,GAAG,GAAG6B,OAAO,CAACnD,MAAM,EAAEK,GAAG,GAAGiB,GAAG,EAAEjB,GAAG,EAAE,EAAE;IACtD+C,OAAO,CAAC/C,GAAG,CAAC,GAAGa,GAAG,CAACiC,OAAO,CAAC9C,GAAG,CAAC,CAAC;EACpC;EACA,OAAO+C,OAAO;AAClB,CAAC;AACD,OAAO,IAAIC,0BAA0B,GAAG,SAAAA,CAAUC,KAAK,EAAE;EACrD,OAAOA,KAAK,YAAYnD,UAAU,IAC9BmD,KAAK,YAAYC,WAAW,IAC5B,OAAOD,KAAK,KAAK,QAAQ;AACjC,CAAC;AACD,OAAO,IAAIE,YAAY,GAAG,SAAAA,CAAUF,KAAK,EAAE;EACvC,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC3B,OAAO1D,uBAAuB,CAAC0D,KAAK,CAAC;EACzC,CAAC,MACI,IAAIA,KAAK,YAAYC,WAAW,EAAE;IACnC,OAAO,IAAIpD,UAAU,CAACmD,KAAK,CAAC;EAChC,CAAC,MACI,IAAIA,KAAK,YAAYnD,UAAU,EAAE;IAClC,OAAOmD,KAAK;EAChB,CAAC,MACI;IACD,MAAM,IAAIG,SAAS,CAAC,4DAA4D,CAAC;EACrF;AACJ,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}