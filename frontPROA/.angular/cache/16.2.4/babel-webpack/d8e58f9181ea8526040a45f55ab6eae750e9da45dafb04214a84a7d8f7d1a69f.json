{"ast":null,"code":"/* tslint:disable:ban-types */\nimport { values as objectValues } from \"./objects\";\nexport var backtick = function (val) {\n  return \"`\" + val + \"`\";\n};\nexport var singleQuote = function (val) {\n  return \"'\" + val + \"'\";\n};\n// prettier-ignore\nvar formatValue = function (value) {\n  var type = typeof value;\n  if (type === 'string') return singleQuote(value);else if (type === 'undefined') return backtick(value);else return value;\n};\nexport var createValueErrorMsg = function (value, valueName, values) {\n  var allowedValues = new Array(values.length);\n  for (var idx = 0, len = values.length; idx < len; idx++) {\n    var v = values[idx];\n    allowedValues[idx] = formatValue(v);\n  }\n  var joinedValues = allowedValues.join(' or ');\n  // prettier-ignore\n  return backtick(valueName) + \" must be one of \" + joinedValues + \", but was actually \" + formatValue(value);\n};\nexport var assertIsOneOf = function (value, valueName, allowedValues) {\n  if (!Array.isArray(allowedValues)) {\n    allowedValues = objectValues(allowedValues);\n  }\n  for (var idx = 0, len = allowedValues.length; idx < len; idx++) {\n    if (value === allowedValues[idx]) return;\n  }\n  throw new TypeError(createValueErrorMsg(value, valueName, allowedValues));\n};\nexport var assertIsOneOfOrUndefined = function (value, valueName, allowedValues) {\n  if (!Array.isArray(allowedValues)) {\n    allowedValues = objectValues(allowedValues);\n  }\n  assertIsOneOf(value, valueName, allowedValues.concat(undefined));\n};\nexport var assertIsSubset = function (values, valueName, allowedValues) {\n  if (!Array.isArray(allowedValues)) {\n    allowedValues = objectValues(allowedValues);\n  }\n  for (var idx = 0, len = values.length; idx < len; idx++) {\n    assertIsOneOf(values[idx], valueName, allowedValues);\n  }\n};\nexport var getType = function (val) {\n  if (val === null) return 'null';\n  if (val === undefined) return 'undefined';\n  if (typeof val === 'string') return 'string';\n  if (isNaN(val)) return 'NaN';\n  if (typeof val === 'number') return 'number';\n  if (typeof val === 'boolean') return 'boolean';\n  if (typeof val === 'symbol') return 'symbol';\n  if (typeof val === 'bigint') return 'bigint';\n  if (val.constructor && val.constructor.name) return val.constructor.name;\n  if (val.name) return val.name;\n  if (val.constructor) return String(val.constructor);\n  return String(val);\n};\nexport var isType = function (value, type) {\n  if (type === 'null') return value === null;\n  if (type === 'undefined') return value === undefined;\n  if (type === 'string') return typeof value === 'string';\n  if (type === 'number') return typeof value === 'number' && !isNaN(value);\n  if (type === 'boolean') return typeof value === 'boolean';\n  if (type === 'symbol') return typeof value === 'symbol';\n  if (type === 'bigint') return typeof value === 'bigint';\n  if (type === Date) return value instanceof Date;\n  if (type === Array) return value instanceof Array;\n  if (type === Uint8Array) return value instanceof Uint8Array;\n  if (type === ArrayBuffer) return value instanceof ArrayBuffer;\n  if (type === Function) return value instanceof Function;\n  return value instanceof type[0];\n};\nexport var createTypeErrorMsg = function (value, valueName, types) {\n  var allowedTypes = new Array(types.length);\n  for (var idx = 0, len = types.length; idx < len; idx++) {\n    var type = types[idx];\n    if (type === 'null') allowedTypes[idx] = backtick('null');\n    if (type === 'undefined') allowedTypes[idx] = backtick('undefined');\n    if (type === 'string') allowedTypes[idx] = backtick('string');else if (type === 'number') allowedTypes[idx] = backtick('number');else if (type === 'boolean') allowedTypes[idx] = backtick('boolean');else if (type === 'symbol') allowedTypes[idx] = backtick('symbol');else if (type === 'bigint') allowedTypes[idx] = backtick('bigint');else if (type === Array) allowedTypes[idx] = backtick('Array');else if (type === Uint8Array) allowedTypes[idx] = backtick('Uint8Array');else if (type === ArrayBuffer) allowedTypes[idx] = backtick('ArrayBuffer');else allowedTypes[idx] = backtick(type[1]);\n  }\n  var joinedTypes = allowedTypes.join(' or ');\n  // prettier-ignore\n  return backtick(valueName) + \" must be of type \" + joinedTypes + \", but was actually of type \" + backtick(getType(value));\n};\nexport var assertIs = function (value, valueName, types) {\n  for (var idx = 0, len = types.length; idx < len; idx++) {\n    if (isType(value, types[idx])) return;\n  }\n  throw new TypeError(createTypeErrorMsg(value, valueName, types));\n};\nexport var assertOrUndefined = function (value, valueName, types) {\n  assertIs(value, valueName, types.concat('undefined'));\n};\nexport var assertEachIs = function (values, valueName, types) {\n  for (var idx = 0, len = values.length; idx < len; idx++) {\n    assertIs(values[idx], valueName, types);\n  }\n};\nexport var assertRange = function (value, valueName, min, max) {\n  assertIs(value, valueName, ['number']);\n  assertIs(min, 'min', ['number']);\n  assertIs(max, 'max', ['number']);\n  max = Math.max(min, max);\n  if (value < min || value > max) {\n    // prettier-ignore\n    throw new Error(backtick(valueName) + \" must be at least \" + min + \" and at most \" + max + \", but was actually \" + value);\n  }\n};\nexport var assertRangeOrUndefined = function (value, valueName, min, max) {\n  assertIs(value, valueName, ['number', 'undefined']);\n  if (typeof value === 'number') assertRange(value, valueName, min, max);\n};\nexport var assertMultiple = function (value, valueName, multiplier) {\n  assertIs(value, valueName, ['number']);\n  if (value % multiplier !== 0) {\n    // prettier-ignore\n    throw new Error(backtick(valueName) + \" must be a multiple of \" + multiplier + \", but was actually \" + value);\n  }\n};\nexport var assertInteger = function (value, valueName) {\n  if (!Number.isInteger(value)) {\n    throw new Error(backtick(valueName) + \" must be an integer, but was actually \" + value);\n  }\n};\nexport var assertPositive = function (value, valueName) {\n  if (![1, 0].includes(Math.sign(value))) {\n    // prettier-ignore\n    throw new Error(backtick(valueName) + \" must be a positive number or 0, but was actually \" + value);\n  }\n};\n//# sourceMappingURL=validators.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}