{"ast":null,"code":"import PDFArray from \"./objects/PDFArray\";\nimport PDFDict from \"./objects/PDFDict\";\nimport PDFName from \"./objects/PDFName\";\nimport PDFRef from \"./objects/PDFRef\";\nimport PDFStream from \"./objects/PDFStream\";\nimport PDFPageLeaf from \"./structures/PDFPageLeaf\";\n/**\n * PDFObjectCopier copies PDFObjects from a src context to a dest context.\n * The primary use case for this is to copy pages between PDFs.\n *\n * _Copying_ an object with a PDFObjectCopier is different from _cloning_ an\n * object with its [[PDFObject.clone]] method:\n *\n * ```\n *   const src: PDFContext = ...\n *   const dest: PDFContext = ...\n *   const originalObject: PDFObject = ...\n *   const copiedObject = PDFObjectCopier.for(src, dest).copy(originalObject);\n *   const clonedObject = originalObject.clone();\n * ```\n *\n * Copying an object is equivalent to cloning it and then copying over any other\n * objects that it references. Note that only dictionaries, arrays, and streams\n * (or structures build from them) can contain indirect references to other\n * objects. Copying a PDFObject that is not a dictionary, array, or stream is\n * supported, but is equivalent to cloning it.\n */\nvar PDFObjectCopier = /** @class */function () {\n  function PDFObjectCopier(src, dest) {\n    var _this = this;\n    this.traversedObjects = new Map();\n    // prettier-ignore\n    this.copy = function (object) {\n      return object instanceof PDFPageLeaf ? _this.copyPDFPage(object) : object instanceof PDFDict ? _this.copyPDFDict(object) : object instanceof PDFArray ? _this.copyPDFArray(object) : object instanceof PDFStream ? _this.copyPDFStream(object) : object instanceof PDFRef ? _this.copyPDFIndirectObject(object) : object.clone();\n    };\n    this.copyPDFPage = function (originalPage) {\n      var clonedPage = originalPage.clone();\n      // Move any entries that the originalPage is inheriting from its parent\n      // tree nodes directly into originalPage so they are preserved during\n      // the copy.\n      var InheritableEntries = PDFPageLeaf.InheritableEntries;\n      for (var idx = 0, len = InheritableEntries.length; idx < len; idx++) {\n        var key = PDFName.of(InheritableEntries[idx]);\n        var value = clonedPage.getInheritableAttribute(key);\n        if (!clonedPage.get(key) && value) clonedPage.set(key, value);\n      }\n      // Remove the parent reference to prevent the whole donor document's page\n      // tree from being copied when we only need a single page.\n      clonedPage.delete(PDFName.of('Parent'));\n      return _this.copyPDFDict(clonedPage);\n    };\n    this.copyPDFDict = function (originalDict) {\n      if (_this.traversedObjects.has(originalDict)) {\n        return _this.traversedObjects.get(originalDict);\n      }\n      var clonedDict = originalDict.clone(_this.dest);\n      _this.traversedObjects.set(originalDict, clonedDict);\n      var entries = originalDict.entries();\n      for (var idx = 0, len = entries.length; idx < len; idx++) {\n        var _a = entries[idx],\n          key = _a[0],\n          value = _a[1];\n        clonedDict.set(key, _this.copy(value));\n      }\n      return clonedDict;\n    };\n    this.copyPDFArray = function (originalArray) {\n      if (_this.traversedObjects.has(originalArray)) {\n        return _this.traversedObjects.get(originalArray);\n      }\n      var clonedArray = originalArray.clone(_this.dest);\n      _this.traversedObjects.set(originalArray, clonedArray);\n      for (var idx = 0, len = originalArray.size(); idx < len; idx++) {\n        var value = originalArray.get(idx);\n        clonedArray.set(idx, _this.copy(value));\n      }\n      return clonedArray;\n    };\n    this.copyPDFStream = function (originalStream) {\n      if (_this.traversedObjects.has(originalStream)) {\n        return _this.traversedObjects.get(originalStream);\n      }\n      var clonedStream = originalStream.clone(_this.dest);\n      _this.traversedObjects.set(originalStream, clonedStream);\n      var entries = originalStream.dict.entries();\n      for (var idx = 0, len = entries.length; idx < len; idx++) {\n        var _a = entries[idx],\n          key = _a[0],\n          value = _a[1];\n        clonedStream.dict.set(key, _this.copy(value));\n      }\n      return clonedStream;\n    };\n    this.copyPDFIndirectObject = function (ref) {\n      var alreadyMapped = _this.traversedObjects.has(ref);\n      if (!alreadyMapped) {\n        var newRef = _this.dest.nextRef();\n        _this.traversedObjects.set(ref, newRef);\n        var dereferencedValue = _this.src.lookup(ref);\n        if (dereferencedValue) {\n          var cloned = _this.copy(dereferencedValue);\n          _this.dest.assign(newRef, cloned);\n        }\n      }\n      return _this.traversedObjects.get(ref);\n    };\n    this.src = src;\n    this.dest = dest;\n  }\n  PDFObjectCopier.for = function (src, dest) {\n    return new PDFObjectCopier(src, dest);\n  };\n  return PDFObjectCopier;\n}();\nexport default PDFObjectCopier;","map":{"version":3,"names":["PDFArray","PDFDict","PDFName","PDFRef","PDFStream","PDFPageLeaf","PDFObjectCopier","src","dest","_this","traversedObjects","Map","copy","object","copyPDFPage","copyPDFDict","copyPDFArray","copyPDFStream","copyPDFIndirectObject","clone","originalPage","clonedPage","InheritableEntries","idx","len","length","key","of","value","getInheritableAttribute","get","set","delete","originalDict","has","clonedDict","entries","_a","originalArray","clonedArray","size","originalStream","clonedStream","dict","ref","alreadyMapped","newRef","nextRef","dereferencedValue","lookup","cloned","assign","for"],"sources":["E:/PROA/frontPROA/node_modules/pdf-lib/es/core/PDFObjectCopier.js"],"sourcesContent":["import PDFArray from \"./objects/PDFArray\";\nimport PDFDict from \"./objects/PDFDict\";\nimport PDFName from \"./objects/PDFName\";\nimport PDFRef from \"./objects/PDFRef\";\nimport PDFStream from \"./objects/PDFStream\";\nimport PDFPageLeaf from \"./structures/PDFPageLeaf\";\n/**\n * PDFObjectCopier copies PDFObjects from a src context to a dest context.\n * The primary use case for this is to copy pages between PDFs.\n *\n * _Copying_ an object with a PDFObjectCopier is different from _cloning_ an\n * object with its [[PDFObject.clone]] method:\n *\n * ```\n *   const src: PDFContext = ...\n *   const dest: PDFContext = ...\n *   const originalObject: PDFObject = ...\n *   const copiedObject = PDFObjectCopier.for(src, dest).copy(originalObject);\n *   const clonedObject = originalObject.clone();\n * ```\n *\n * Copying an object is equivalent to cloning it and then copying over any other\n * objects that it references. Note that only dictionaries, arrays, and streams\n * (or structures build from them) can contain indirect references to other\n * objects. Copying a PDFObject that is not a dictionary, array, or stream is\n * supported, but is equivalent to cloning it.\n */\nvar PDFObjectCopier = /** @class */ (function () {\n    function PDFObjectCopier(src, dest) {\n        var _this = this;\n        this.traversedObjects = new Map();\n        // prettier-ignore\n        this.copy = function (object) { return (object instanceof PDFPageLeaf ? _this.copyPDFPage(object)\n            : object instanceof PDFDict ? _this.copyPDFDict(object)\n                : object instanceof PDFArray ? _this.copyPDFArray(object)\n                    : object instanceof PDFStream ? _this.copyPDFStream(object)\n                        : object instanceof PDFRef ? _this.copyPDFIndirectObject(object)\n                            : object.clone()); };\n        this.copyPDFPage = function (originalPage) {\n            var clonedPage = originalPage.clone();\n            // Move any entries that the originalPage is inheriting from its parent\n            // tree nodes directly into originalPage so they are preserved during\n            // the copy.\n            var InheritableEntries = PDFPageLeaf.InheritableEntries;\n            for (var idx = 0, len = InheritableEntries.length; idx < len; idx++) {\n                var key = PDFName.of(InheritableEntries[idx]);\n                var value = clonedPage.getInheritableAttribute(key);\n                if (!clonedPage.get(key) && value)\n                    clonedPage.set(key, value);\n            }\n            // Remove the parent reference to prevent the whole donor document's page\n            // tree from being copied when we only need a single page.\n            clonedPage.delete(PDFName.of('Parent'));\n            return _this.copyPDFDict(clonedPage);\n        };\n        this.copyPDFDict = function (originalDict) {\n            if (_this.traversedObjects.has(originalDict)) {\n                return _this.traversedObjects.get(originalDict);\n            }\n            var clonedDict = originalDict.clone(_this.dest);\n            _this.traversedObjects.set(originalDict, clonedDict);\n            var entries = originalDict.entries();\n            for (var idx = 0, len = entries.length; idx < len; idx++) {\n                var _a = entries[idx], key = _a[0], value = _a[1];\n                clonedDict.set(key, _this.copy(value));\n            }\n            return clonedDict;\n        };\n        this.copyPDFArray = function (originalArray) {\n            if (_this.traversedObjects.has(originalArray)) {\n                return _this.traversedObjects.get(originalArray);\n            }\n            var clonedArray = originalArray.clone(_this.dest);\n            _this.traversedObjects.set(originalArray, clonedArray);\n            for (var idx = 0, len = originalArray.size(); idx < len; idx++) {\n                var value = originalArray.get(idx);\n                clonedArray.set(idx, _this.copy(value));\n            }\n            return clonedArray;\n        };\n        this.copyPDFStream = function (originalStream) {\n            if (_this.traversedObjects.has(originalStream)) {\n                return _this.traversedObjects.get(originalStream);\n            }\n            var clonedStream = originalStream.clone(_this.dest);\n            _this.traversedObjects.set(originalStream, clonedStream);\n            var entries = originalStream.dict.entries();\n            for (var idx = 0, len = entries.length; idx < len; idx++) {\n                var _a = entries[idx], key = _a[0], value = _a[1];\n                clonedStream.dict.set(key, _this.copy(value));\n            }\n            return clonedStream;\n        };\n        this.copyPDFIndirectObject = function (ref) {\n            var alreadyMapped = _this.traversedObjects.has(ref);\n            if (!alreadyMapped) {\n                var newRef = _this.dest.nextRef();\n                _this.traversedObjects.set(ref, newRef);\n                var dereferencedValue = _this.src.lookup(ref);\n                if (dereferencedValue) {\n                    var cloned = _this.copy(dereferencedValue);\n                    _this.dest.assign(newRef, cloned);\n                }\n            }\n            return _this.traversedObjects.get(ref);\n        };\n        this.src = src;\n        this.dest = dest;\n    }\n    PDFObjectCopier.for = function (src, dest) {\n        return new PDFObjectCopier(src, dest);\n    };\n    return PDFObjectCopier;\n}());\nexport default PDFObjectCopier;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}