{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { PrivateConstructorError } from \"../errors\";\nimport PDFObject from \"./PDFObject\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { IsIrregular } from \"../syntax/Irregular\";\nimport { charFromHexCode, copyStringIntoBuffer, toCharCode, toHexString } from \"../../utils\";\nvar decodeName = function (name) {\n  return name.replace(/#([\\dABCDEF]{2})/g, function (_, hex) {\n    return charFromHexCode(hex);\n  });\n};\nvar isRegularChar = function (charCode) {\n  return charCode >= CharCodes.ExclamationPoint && charCode <= CharCodes.Tilde && !IsIrregular[charCode];\n};\nvar ENFORCER = {};\nvar pool = new Map();\nvar PDFName = /** @class */function (_super) {\n  __extends(PDFName, _super);\n  function PDFName(enforcer, name) {\n    var _this = this;\n    if (enforcer !== ENFORCER) throw new PrivateConstructorError('PDFName');\n    _this = _super.call(this) || this;\n    var encodedName = '/';\n    for (var idx = 0, len = name.length; idx < len; idx++) {\n      var character = name[idx];\n      var code = toCharCode(character);\n      encodedName += isRegularChar(code) ? character : \"#\" + toHexString(code);\n    }\n    _this.encodedName = encodedName;\n    return _this;\n  }\n  PDFName.prototype.asBytes = function () {\n    var bytes = [];\n    var hex = '';\n    var escaped = false;\n    var pushByte = function (byte) {\n      if (byte !== undefined) bytes.push(byte);\n      escaped = false;\n    };\n    for (var idx = 1, len = this.encodedName.length; idx < len; idx++) {\n      var char = this.encodedName[idx];\n      var byte = toCharCode(char);\n      var nextChar = this.encodedName[idx + 1];\n      if (!escaped) {\n        if (byte === CharCodes.Hash) escaped = true;else pushByte(byte);\n      } else {\n        if (byte >= CharCodes.Zero && byte <= CharCodes.Nine || byte >= CharCodes.a && byte <= CharCodes.f || byte >= CharCodes.A && byte <= CharCodes.F) {\n          hex += char;\n          if (hex.length === 2 || !(nextChar >= '0' && nextChar <= '9' || nextChar >= 'a' && nextChar <= 'f' || nextChar >= 'A' && nextChar <= 'F')) {\n            pushByte(parseInt(hex, 16));\n            hex = '';\n          }\n        } else {\n          pushByte(byte);\n        }\n      }\n    }\n    return new Uint8Array(bytes);\n  };\n  // TODO: This should probably use `utf8Decode()`\n  // TODO: Polyfill Array.from?\n  PDFName.prototype.decodeText = function () {\n    var bytes = this.asBytes();\n    return String.fromCharCode.apply(String, Array.from(bytes));\n  };\n  PDFName.prototype.asString = function () {\n    return this.encodedName;\n  };\n  /** @deprecated in favor of [[PDFName.asString]] */\n  PDFName.prototype.value = function () {\n    return this.encodedName;\n  };\n  PDFName.prototype.clone = function () {\n    return this;\n  };\n  PDFName.prototype.toString = function () {\n    return this.encodedName;\n  };\n  PDFName.prototype.sizeInBytes = function () {\n    return this.encodedName.length;\n  };\n  PDFName.prototype.copyBytesInto = function (buffer, offset) {\n    offset += copyStringIntoBuffer(this.encodedName, buffer, offset);\n    return this.encodedName.length;\n  };\n  PDFName.of = function (name) {\n    var decodedValue = decodeName(name);\n    var instance = pool.get(decodedValue);\n    if (!instance) {\n      instance = new PDFName(ENFORCER, decodedValue);\n      pool.set(decodedValue, instance);\n    }\n    return instance;\n  };\n  /* tslint:disable member-ordering */\n  PDFName.Length = PDFName.of('Length');\n  PDFName.FlateDecode = PDFName.of('FlateDecode');\n  PDFName.Resources = PDFName.of('Resources');\n  PDFName.Font = PDFName.of('Font');\n  PDFName.XObject = PDFName.of('XObject');\n  PDFName.ExtGState = PDFName.of('ExtGState');\n  PDFName.Contents = PDFName.of('Contents');\n  PDFName.Type = PDFName.of('Type');\n  PDFName.Parent = PDFName.of('Parent');\n  PDFName.MediaBox = PDFName.of('MediaBox');\n  PDFName.Page = PDFName.of('Page');\n  PDFName.Annots = PDFName.of('Annots');\n  PDFName.TrimBox = PDFName.of('TrimBox');\n  PDFName.ArtBox = PDFName.of('ArtBox');\n  PDFName.BleedBox = PDFName.of('BleedBox');\n  PDFName.CropBox = PDFName.of('CropBox');\n  PDFName.Rotate = PDFName.of('Rotate');\n  PDFName.Title = PDFName.of('Title');\n  PDFName.Author = PDFName.of('Author');\n  PDFName.Subject = PDFName.of('Subject');\n  PDFName.Creator = PDFName.of('Creator');\n  PDFName.Keywords = PDFName.of('Keywords');\n  PDFName.Producer = PDFName.of('Producer');\n  PDFName.CreationDate = PDFName.of('CreationDate');\n  PDFName.ModDate = PDFName.of('ModDate');\n  return PDFName;\n}(PDFObject);\nexport default PDFName;\n//# sourceMappingURL=PDFName.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}